diff -rup libcgroup-0.41/src/api.c libcgroup-0.41/src/api.c
--- libcgroup-0.41/src/api.c	2014-01-13 15:05:56.000000000 +0100
+++ libcgroup-0.41/src/api.c	2015-09-08 21:02:14.000000000 +0200
@@ -1897,15 +1897,25 @@ static int cg_move_task_files(FILE *inpu
 			break;

 		ret = fprintf(output_tasks, "%d", tids);
-		if (ret < 0)
-			break;
+		if (ret < 0) {
+			if (errno == ESRCH) {
+				ret = 0;
+			} else {
+				break;
+			}
+		}

 		/*
 		 * Flush the file, we need only one process per write() call.
 		 */
 		ret = fflush(output_tasks);
-		if (ret < 0)
-			break;
+		if (ret < 0) {
+			if (errno == ESRCH) {
+				ret = 0;
+			} else {
+				break;
+			}
+		}
 	}

 	if (ret < 0) {
@@ -2594,13 +2604,17 @@ static struct cgroup_rule *cgroup_find_m
 			/* Get the group data. */
 			sp = &(rule->username[1]);
 			grp = getgrnam(sp);
-			if (!grp)
+			if (!grp) {
+				rule = rule->next;
 				continue;
+			}

 			/* Get the data for UID. */
 			usr = getpwuid(uid);
-			if (!usr)
+			if (!usr) {
+				rule = rule->next;
 				continue;
+			}

 			/* If UID is a member of group, we matched. */
 			for (i = 0; grp->gr_mem[i]; i++) {
@@ -4054,6 +4068,9 @@ int cgroup_get_procname_from_procfs(pid_
 		 * readlink() fails if a kernel thread, and a process
 		 * name is taken from /proc/<pid>/status.
 		 */
+		free(pname_status);
+		pname_status = malloc(sizeof("__KERNEL__"));
+		memcpy(pname_status, "__KERNEL__", sizeof("__KERNEL__"));
 		*procname = pname_status;
 		return 0;
 	}
@@ -4090,10 +4107,10 @@ int cgroup_get_procname_from_procfs(pid_
 	/*
 	 * The above strncmp() is not 0 also if executing a symbolic link,
 	 * /proc/pid/exe points to real executable name then.
-	 * Return it as the last resort.
+	 * As the last resort, return name from /proc/<pid>/status.
 	 */
+	*procname = strdup(pname_status);
 	free(pname_status);
-	*procname = strdup(buf);
 	if (*procname == NULL) {
 		last_errno = errno;
 		return ECGOTHER;
diff -rup libcgroup-0.41/src/config.c libcgroup-0.41/src/config.c
--- libcgroup-0.41/src/config.c	2014-01-13 15:05:56.000000000 +0100
+++ libcgroup-0.41/src/config.c	2015-09-08 13:05:11.000000000 +0200
@@ -217,7 +217,7 @@ int config_parse_controller_options(char
 	struct cgroup_dictionary *values, int flag)
 {
 	const char *name, *value;
-	struct cgroup_controller *cgc;
+	struct cgroup_controller *cgc = NULL;
 	int error;
 	struct cgroup *config_cgroup;
 	void *iter = NULL;
@@ -1583,7 +1583,7 @@ int cgroup_config_create_template_group(
 	int i, j, k;
 	struct cgroup *t_cgroup;
 	char buffer[FILENAME_MAX];
-	struct cgroup *aux_cgroup;
+	struct cgroup *aux_cgroup = NULL;
 	struct cgroup_controller *cgc;
 	int found;

@@ -1659,9 +1659,9 @@ int cgroup_config_create_template_group(
 		/* no template is present for given name x controller pair
 		 * add controller to result cgroup */
 		aux_cgroup = cgroup_new_cgroup(cgroup->name);
-		if (aux_cgroup) {
+		if (aux_cgroup == NULL) {
 			ret = ECGINVAL;
-			fprintf(stderr, "cgroup %s can't be created\n",
+			fprintf(stderr, "cgroup %s can't be created: cgroup_new_cgroup()\n",
 				cgroup->name);
 			goto end;
 		}
@@ -1669,19 +1669,22 @@ int cgroup_config_create_template_group(
 			(cgroup->controller[i])->name);
 		if (cgc == NULL) {
 			ret = ECGINVAL;
-			fprintf(stderr, "cgroup %s can't be created\n",
+			fprintf(stderr, "cgroup %s can't be created: cgroup_add_controller()\n",
 				cgroup->name);
 			goto end;
 		}
 		ret = cgroup_create_cgroup(aux_cgroup, flags);
 		if (ret) {
 			ret = ECGINVAL;
-			fprintf(stderr, "cgroup %s can't be created\n",
+			fprintf(stderr, "cgroup %s can't be created: cgroup_create_cgroup()\n",
 				cgroup->name);
 			goto end;
 		}
 	}

 end:
+	if(aux_cgroup) {
+		free(aux_cgroup);
+	}
 	return ret;
 }
diff -rup libcgroup-0.41/src/daemon/cgrulesengd.c libcgroup-0.41/src/daemon/cgrulesengd.c
--- libcgroup-0.41/src/daemon/cgrulesengd.c	2014-01-13 15:05:56.000000000 +0100
+++ libcgroup-0.41/src/daemon/cgrulesengd.c	2015-09-08 20:16:30.000000000 +0200
@@ -772,6 +772,9 @@ static int cgre_create_netlink_socket_pr

 		memcpy(&fds, &readfds, sizeof(fd_set));
 		if (select(sk_max + 1, &fds, NULL, NULL, NULL) < 0) {
+			if(errno == EINTR) {
+				continue;
+			}
 			flog(LOG_ERR, "Selecting error: %s\n", strerror(errno));
 			goto close_and_exit;
 		}
@@ -950,6 +953,9 @@ void cgre_flash_rules(int signum)

 	/* Ask libcgroup to reload the template rules table. */
 	cgroup_reload_cached_templates(CGCONFIG_CONF_FILE);
+
+	/* Reapply cgroups to running processes. */
+	cgroup_change_all_cgroups();
 }

 /**
@@ -967,6 +973,9 @@ void cgre_flash_templates(int signum)

 	/* Ask libcgroup to reload the templates table. */
 	cgroup_reload_cached_templates(CGCONFIG_CONF_FILE);
+
+	/* Reapply cgroups to running processes. */
+	cgroup_change_all_cgroups();
 }

 /**
