diff --git OTP_VERSION OTP_VERSION
index 1c6a6689e..2b1022602 100644
--- OTP_VERSION
+++ OTP_VERSION
@@ -1 +1 @@
-19.3.6
+19.3.6.1
diff --git erts/doc/src/erlang.xml erts/doc/src/erlang.xml
index c3b0bc0d7..24a091073 100644
--- erts/doc/src/erlang.xml
+++ erts/doc/src/erlang.xml
@@ -6362,6 +6362,9 @@ lists:map(
         <p>This is the sum of the runtime for all threads
           in the Erlang runtime system and can therefore be greater
           than the wall clock time.</p>
+          <warning><p>This value might wrap due to limitations in the
+          underlying functionality provided by the operating system
+          that is used.</p></warning>
         <p>Example:</p>
         <pre>
 > <input>statistics(runtime).</input>
diff --git erts/doc/src/notes.xml erts/doc/src/notes.xml
index 02b4de404..48475ae30 100644
--- erts/doc/src/notes.xml
+++ erts/doc/src/notes.xml
@@ -31,6 +31,42 @@
   </header>
   <p>This document describes the changes made to the ERTS application.</p>
 
+<section><title>Erts 8.3.5.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    Fixed a bug in gen_tcp:send where it never returned when
+	    repeatedly called on a remotely closed TCP socket.</p>
+          <p>
+	    Own Id: OTP-13939 Aux Id: ERL-193 </p>
+        </item>
+        <item>
+          <p>
+	    Fixed segfault that could happen during cleanup of
+	    aborted erlang:port_command/3 calls. A port_command is
+	    aborted if the port is closed at the same time as the
+	    port_command was issued. This bug was introduced in
+	    erts-8.0.</p>
+          <p>
+	    Own Id: OTP-14481</p>
+        </item>
+        <item>
+          <p>
+	    Fixed implementation of <c>statistics(wall_clock)</c> and
+	    <c>statistics(runtime)</c> so that values do not
+	    unnecessarily wrap due to the emulator. Note that the
+	    values returned by <c>statistics(runtime)</c> may still
+	    wrap due to limitations in the underlying functionality
+	    provided by the operating system.</p>
+          <p>
+	    Own Id: OTP-14484</p>
+        </item>
+      </list>
+    </section>
+
+</section>
 
 <section><title>Erts 8.3.5</title>
 
@@ -562,6 +598,22 @@
 
 </section>
 
+<section><title>Erts 8.1.1.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    A code purge operation could under certain circumstances
+	    expand the size of hibernated processes.</p>
+          <p>
+	    Own Id: OTP-14444 Aux Id: ERIERL-24 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Erts 8.1.1</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git erts/emulator/beam/erl_bif_info.c erts/emulator/beam/erl_bif_info.c
index 7bd45916f..7791231d5 100644
--- erts/emulator/beam/erl_bif_info.c
+++ erts/emulator/beam/erl_bif_info.c
@@ -3468,24 +3468,32 @@ BIF_RETTYPE statistics_1(BIF_ALIST_1)
 	res = TUPLE2(hp, b1, b2); 
 	BIF_RET(res);
     } else if (BIF_ARG_1 == am_runtime) {
-	UWord u1, u2, dummy;
+	ErtsMonotonicTime u1, u2;
 	Eterm b1, b2;
-	elapsed_time_both(&u1,&dummy,&u2,&dummy);
-	b1 = erts_make_integer(u1,BIF_P);
-	b2 = erts_make_integer(u2,BIF_P);
-	hp = HAlloc(BIF_P,3);
+        Uint hsz;
+	elapsed_time_both(&u1, NULL, &u2, NULL);
+        hsz = 3; /* 2-tuple */
+        (void) erts_bld_monotonic_time(NULL, &hsz, u1);
+        (void) erts_bld_monotonic_time(NULL, &hsz, u2);
+	hp = HAlloc(BIF_P, hsz);
+        b1 = erts_bld_monotonic_time(&hp, NULL, u1);
+        b2 = erts_bld_monotonic_time(&hp, NULL, u2);
 	res = TUPLE2(hp, b1, b2);
 	BIF_RET(res);
     } else if (BIF_ARG_1 ==  am_run_queue) {
 	res = erts_run_queues_len(NULL, 1, 0);
 	BIF_RET(make_small(res));
     } else if (BIF_ARG_1 == am_wall_clock) {
-	UWord w1, w2;
+	ErtsMonotonicTime w1, w2;
 	Eterm b1, b2;
+        Uint hsz;
 	wall_clock_elapsed_time_both(&w1, &w2);
-	b1 = erts_make_integer((Uint) w1,BIF_P);
-	b2 = erts_make_integer((Uint) w2,BIF_P);
-	hp = HAlloc(BIF_P,3);
+        hsz = 3; /* 2-tuple */
+        (void) erts_bld_monotonic_time(NULL, &hsz, w1);
+        (void) erts_bld_monotonic_time(NULL, &hsz, w2);
+	hp = HAlloc(BIF_P, hsz);
+        b1 = erts_bld_monotonic_time(&hp, NULL, w1);
+        b2 = erts_bld_monotonic_time(&hp, NULL, w2);
 	res = TUPLE2(hp, b1, b2);
 	BIF_RET(res);
     } else if (BIF_ARG_1 == am_io) {
diff --git erts/emulator/beam/erl_port_task.c erts/emulator/beam/erl_port_task.c
index 3102e44c1..2083a43f6 100644
--- erts/emulator/beam/erl_port_task.c
+++ erts/emulator/beam/erl_port_task.c
@@ -852,10 +852,11 @@ schedule_port_task_handle_list_free(ErtsPortTaskHandleList *pthlp)
 }
 
 static ERTS_INLINE void
-abort_nosuspend_task(Port *pp,
-		     ErtsPortTaskType type,
-		     ErtsPortTaskTypeData *tdp,
-		     int bpq_data)
+abort_signal_task(Port *pp,
+                  int abort_type,
+                  ErtsPortTaskType type,
+                  ErtsPortTaskTypeData *tdp,
+                  int bpq_data)
 {
 
     ASSERT(type == ERTS_PORT_TASK_PROC_SIG);
@@ -863,18 +864,28 @@ abort_nosuspend_task(Port *pp,
     if (!bpq_data)
 	tdp->psig.callback(NULL,
 			   ERTS_PORT_SFLG_INVALID,
-			   ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND,
+			   abort_type,
 			   &tdp->psig.data);
     else {
 	ErlDrvSizeT size = erts_proc2port_sig_command_data_size(&tdp->psig.data);
 	tdp->psig.callback(NULL,
 			   ERTS_PORT_SFLG_INVALID,
-			   ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND,
+			   abort_type,
 			   &tdp->psig.data);
 	aborted_proc2port_data(pp, size);
     }
 }
 
+
+static ERTS_INLINE void
+abort_nosuspend_task(Port *pp,
+		     ErtsPortTaskType type,
+		     ErtsPortTaskTypeData *tdp,
+		     int bpq_data)
+{
+    abort_signal_task(pp, ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND, type, tdp, bpq_data);
+}
+
 static ErtsPortTaskHandleList *
 get_free_nosuspend_handles(Port *pp)
 {
@@ -1613,8 +1624,9 @@ abort_nosuspend:
 
     ASSERT(ns_pthlp);
     erts_free(ERTS_ALC_T_PT_HNDL_LIST, ns_pthlp);
-    if (ptp)
-	port_task_free(ptp);
+
+    ASSERT(ptp);
+    port_task_free(ptp);
 
     return 0;
 
@@ -1625,12 +1637,15 @@ fail:
 	erts_port_dec_refc(pp);
 #endif
 
+    if (ptp) {
+        abort_signal_task(pp, ERTS_PROC2PORT_SIG_ABORT,
+                          ptp->type, &ptp->u.alive.td, 0);
+	port_task_free(ptp);
+    }
+
     if (ns_pthlp)
 	erts_free(ERTS_ALC_T_PT_HNDL_LIST, ns_pthlp);
 
-    if (ptp)
-	port_task_free(ptp);
-
     return -1;
 }
 
diff --git erts/emulator/beam/erl_time_sup.c erts/emulator/beam/erl_time_sup.c
index 6aa2a7500..1ef8c1b73 100644
--- erts/emulator/beam/erl_time_sup.c
+++ erts/emulator/beam/erl_time_sup.c
@@ -1289,56 +1289,62 @@ erts_finalize_time_offset(void)
 /* info functions */
 
 void 
-elapsed_time_both(UWord *ms_user, UWord *ms_sys, 
-		  UWord *ms_user_diff, UWord *ms_sys_diff)
+elapsed_time_both(ErtsMonotonicTime *ms_user, ErtsMonotonicTime *ms_sys, 
+		  ErtsMonotonicTime *ms_user_diff, ErtsMonotonicTime *ms_sys_diff)
 {
-    UWord prev_total_user, prev_total_sys;
-    UWord total_user, total_sys;
+    ErtsMonotonicTime prev_total_user, prev_total_sys;
+    ErtsMonotonicTime total_user, total_sys;
     SysTimes now;
 
     sys_times(&now);
-    total_user = (now.tms_utime * 1000) / SYS_CLK_TCK;
-    total_sys = (now.tms_stime * 1000) / SYS_CLK_TCK;
+    total_user = (ErtsMonotonicTime) ((now.tms_utime * 1000) / SYS_CLK_TCK);
+    total_sys = (ErtsMonotonicTime) ((now.tms_stime * 1000) / SYS_CLK_TCK);
 
     if (ms_user != NULL)
 	*ms_user = total_user;
     if (ms_sys != NULL)
 	*ms_sys = total_sys;
 
-    erts_smp_mtx_lock(&erts_timeofday_mtx);
+    if (ms_user_diff || ms_sys_diff) {
+        erts_smp_mtx_lock(&erts_timeofday_mtx);
     
-    prev_total_user = (t_start.tms_utime * 1000) / SYS_CLK_TCK;
-    prev_total_sys = (t_start.tms_stime * 1000) / SYS_CLK_TCK;
-    t_start = now;
+        prev_total_user = (ErtsMonotonicTime) ((t_start.tms_utime * 1000) / SYS_CLK_TCK);
+        prev_total_sys = (ErtsMonotonicTime) ((t_start.tms_stime * 1000) / SYS_CLK_TCK);
+        t_start = now;
     
-    erts_smp_mtx_unlock(&erts_timeofday_mtx);
+        erts_smp_mtx_unlock(&erts_timeofday_mtx);
 
-    if (ms_user_diff != NULL)
-	*ms_user_diff = total_user - prev_total_user;
+        if (ms_user_diff != NULL)
+            *ms_user_diff = total_user - prev_total_user;
 	  
-    if (ms_sys_diff != NULL)
-	*ms_sys_diff = total_sys - prev_total_sys;
+        if (ms_sys_diff != NULL)
+            *ms_sys_diff = total_sys - prev_total_sys;
+    }
 }
 
 
 /* wall clock routines */
 
 void 
-wall_clock_elapsed_time_both(UWord *ms_total, UWord *ms_diff)
+wall_clock_elapsed_time_both(ErtsMonotonicTime *ms_total, ErtsMonotonicTime *ms_diff)
 {
     ErtsMonotonicTime now, elapsed;
 
-    erts_smp_mtx_lock(&erts_timeofday_mtx);
-
     now = time_sup.r.o.get_time();
     update_last_mtime(NULL, now);
 
     elapsed = ERTS_MONOTONIC_TO_MSEC(now);
-    *ms_total = (UWord) elapsed;
-    *ms_diff = (UWord) (elapsed - prev_wall_clock_elapsed);
-    prev_wall_clock_elapsed = elapsed;
 
-    erts_smp_mtx_unlock(&erts_timeofday_mtx);
+    *ms_total = elapsed;
+
+    if (ms_diff) {
+        erts_smp_mtx_lock(&erts_timeofday_mtx);
+
+        *ms_diff = elapsed - prev_wall_clock_elapsed;
+        prev_wall_clock_elapsed = elapsed;
+
+        erts_smp_mtx_unlock(&erts_timeofday_mtx);
+    }
 }
 
 /* get current time */
diff --git erts/emulator/beam/erl_utils.h erts/emulator/beam/erl_utils.h
index 81800752f..b0912a346 100644
--- erts/emulator/beam/erl_utils.h
+++ erts/emulator/beam/erl_utils.h
@@ -132,6 +132,7 @@ Eterm erts_bld_uint(Uint **hpp, Uint *szp, Uint ui);
 Eterm erts_bld_uword(Uint **hpp, Uint *szp, UWord uw);
 Eterm erts_bld_uint64(Uint **hpp, Uint *szp, Uint64 ui64);
 Eterm erts_bld_sint64(Uint **hpp, Uint *szp, Sint64 si64);
+#define erts_bld_monotonic_time erts_bld_sint64
 Eterm erts_bld_cons(Uint **hpp, Uint *szp, Eterm car, Eterm cdr);
 Eterm erts_bld_tuple(Uint **hpp, Uint *szp, Uint arity, ...);
 #define erts_bld_tuple2(H,S,E1,E2) erts_bld_tuple(H,S,2,E1,E2)
diff --git erts/emulator/beam/io.c erts/emulator/beam/io.c
index c3eb610fd..caf8bfc29 100644
--- erts/emulator/beam/io.c
+++ erts/emulator/beam/io.c
@@ -1968,7 +1968,6 @@ int
 erts_port_output_async(Port *prt, Eterm from, Eterm list)
 {
 
-    ErtsPortOpResult res;
     ErtsProc2PortSigData *sigdp;
     erts_driver_t *drv = prt->drv_ptr;
     size_t size;
@@ -2102,26 +2101,18 @@ erts_port_output_async(Port *prt, Eterm from, Eterm list)
 	sigdp->u.output.size = size;
 	port_sig_callback = port_sig_output;
     }
-    sigdp->flags = 0;
     ns_pthp = NULL;
     task_flags = 0;
 
-    res = erts_schedule_proc2port_signal(NULL,
-					 prt,
-					 ERTS_INVALID_PID,
-					 NULL,
-					 sigdp,
-					 task_flags,
-					 ns_pthp,
-					 port_sig_callback);
+    erts_schedule_proc2port_signal(NULL,
+                                   prt,
+                                   ERTS_INVALID_PID,
+                                   NULL,
+                                   sigdp,
+                                   task_flags,
+                                   ns_pthp,
+                                   port_sig_callback);
 
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	if (drv->outputv)
-	    cleanup_scheduled_outputv(evp, cbin);
-	else
-	    cleanup_scheduled_output(buf);
-	return 1;
-    }
     return 1;
 
 bad_value:
@@ -2554,10 +2545,6 @@ erts_port_output(Process *c_p,
 					 port_sig_callback);
 
     if (res != ERTS_PORT_OP_SCHEDULED) {
-	if (drv->outputv)
-	    cleanup_scheduled_outputv(evp, cbin);
-	else
-	    cleanup_scheduled_output(buf);
 	return res;
     }
 
@@ -2736,21 +2723,14 @@ erts_port_exit(Process *c_p,
 					   &bp->off_heap);
     }
 
-    res = erts_schedule_proc2port_signal(c_p,
-					 prt,
-					 c_p ? c_p->common.id : from,
-					 refp,
-					 sigdp,
-					 0,
-					 NULL,
-					 port_sig_exit);
-
-    if (res == ERTS_PORT_OP_DROPPED) {
-	if (bp)
-	    free_message_buffer(bp);
-    }
-
-    return res;
+    return erts_schedule_proc2port_signal(c_p,
+                                          prt,
+                                          c_p ? c_p->common.id : from,
+                                          refp,
+                                          sigdp,
+                                          0,
+                                          NULL,
+                                          port_sig_exit);
 }
 
 static ErtsPortOpResult
@@ -4932,10 +4912,9 @@ erts_port_control(Process* c_p,
 					 0,
 					 NULL,
 					 port_sig_control);
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	cleanup_scheduled_control(binp, bufp);
+    if (res != ERTS_PORT_OP_SCHEDULED)
 	return ERTS_PORT_OP_BADARG;
-    }
+
     return res;
 }
 
@@ -5225,10 +5204,9 @@ erts_port_call(Process* c_p,
 					 0,
 					 NULL,
 					 port_sig_call);
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	cleanup_scheduled_call(bufp);
+    if (res != ERTS_PORT_OP_SCHEDULED)
 	return ERTS_PORT_OP_BADARG;
-    }
+
     return res;
 }
 
diff --git erts/emulator/beam/sys.h erts/emulator/beam/sys.h
index dd4f05686..950583bbf 100644
--- erts/emulator/beam/sys.h
+++ erts/emulator/beam/sys.h
@@ -790,10 +790,10 @@ Preload* sys_preloaded(void);
 unsigned char* sys_preload_begin(Preload*);
 void sys_preload_end(Preload*);
 int sys_get_key(int);
-void elapsed_time_both(UWord *ms_user, UWord *ms_sys, 
-		       UWord *ms_user_diff, UWord *ms_sys_diff);
-void wall_clock_elapsed_time_both(UWord *ms_total, 
-				  UWord *ms_diff);
+void elapsed_time_both(ErtsMonotonicTime *ms_user, ErtsMonotonicTime *ms_sys, 
+		       ErtsMonotonicTime *ms_user_diff, ErtsMonotonicTime *ms_sys_diff);
+void wall_clock_elapsed_time_both(ErtsMonotonicTime *ms_total, 
+				  ErtsMonotonicTime *ms_diff);
 void get_time(int *hour, int *minute, int *second);
 void get_date(int *year, int *month, int *day);
 void get_localtime(int *year, int *month, int *day, 
diff --git erts/emulator/drivers/common/inet_drv.c erts/emulator/drivers/common/inet_drv.c
index ebd13e6f0..edea20885 100644
--- erts/emulator/drivers/common/inet_drv.c
+++ erts/emulator/drivers/common/inet_drv.c
@@ -4320,6 +4320,12 @@ static void desc_close(inet_descriptor* desc)
 	desc->event = INVALID_EVENT; /* closed by stop_select callback */
 	desc->s = INVALID_SOCKET;
 	desc->event_mask = 0;
+
+	/* mark as disconnected in case when socket is left lingering due to
+	 * {exit_on_close, false} option in gen_tcp socket creation. Next
+	 * write to socket should produce {error, enotconn} and send a
+	 * message {tcp_error,#Port<>,econnreset} */
+	desc->state &= ~INET_STATE_CONNECTED;
     }
 }
 
diff --git erts/emulator/test/port_SUITE.erl erts/emulator/test/port_SUITE.erl
index 23594aa8c..3a2243f55 100644
--- erts/emulator/test/port_SUITE.erl
+++ erts/emulator/test/port_SUITE.erl
@@ -86,6 +86,7 @@
     cd_relative/1,
     close_deaf_port/1,
     count_fds/1,
+    dropped_commands/1,
     dying_port/1,
     env/1,
     eof/1,
@@ -548,6 +549,45 @@ make_dying_port(Config) when is_list(Config) ->
     Command = lists:concat([PortTest, " -h0 -d -q"]),
     open_port({spawn, Command}, [stream]).
 
+%% Test that dropped port_commands work correctly.
+%% This used to cause a segfault.
+%%
+%% This testcase creates a port and then lets many processes
+%% do parallel commands to it. After a while it closes the
+%% port and we are trying to catch the race when doing a
+%% command while the port is closing.
+dropped_commands(Config) ->
+    %% Test with output callback
+    dropped_commands(Config, false, {self(), {command, "1"}}),
+    %% Test with outputv callback
+    dropped_commands(Config, true, {self(), {command, "1"}}).
+
+dropped_commands(Config, Outputv, Cmd) ->
+    Path = proplists:get_value(data_dir, Config),
+    os:putenv("ECHO_DRV_USE_OUTPUTV", atom_to_list(Outputv)),
+    ok = load_driver(Path, "echo_drv"),
+    [dropped_commands_test(Cmd) || _ <- lists:seq(1, 100)],
+    timer:sleep(100),
+    erl_ddll:unload_driver("echo_drv"),
+    ok.
+
+dropped_commands_test(Cmd) ->
+    Port = erlang:open_port({spawn_driver, "echo_drv"}, [{parallelism, true}]),
+    spawn_monitor(
+      fun() ->
+              [spawn_link(fun() -> spin(Port, Cmd) end) || _ <- lists:seq(1,8)],
+              timer:sleep(5),
+              port_close(Port),
+              timer:sleep(5),
+              exit(nok)
+      end),
+    receive _M -> timer:sleep(5) end.
+
+spin(P, Cmd) ->
+    P ! Cmd,
+    spin(P, Cmd).
+
+
 %% Tests that port program with complete path (but without any
 %% .exe extension) can be started, even if there is a file with
 %% the same name but without the extension in the same directory.
diff --git erts/emulator/test/port_SUITE_data/echo_drv.c erts/emulator/test/port_SUITE_data/echo_drv.c
index 1d39c6a00..b4370f645 100644
--- erts/emulator/test/port_SUITE_data/echo_drv.c
+++ erts/emulator/test/port_SUITE_data/echo_drv.c
@@ -18,8 +18,11 @@ typedef struct _erl_drv_data EchoDrvData;
 
 static EchoDrvData *echo_drv_start(ErlDrvPort port, char *command);
 static void         echo_drv_stop(EchoDrvData *data_p);
-static void         echo_drv_output(ErlDrvData drv_data, char *buf,
-				    ErlDrvSizeT len);
+static void         echo_drv_output(ErlDrvData drv_data, char *buf, ErlDrvSizeT len);
+static ErlDrvSSizeT echo_control(ErlDrvData drv_data,
+                                 unsigned int command, char *buf,
+                                 ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen);
+static void         echo_outputv(ErlDrvData drv_data, ErlIOVec *ev);
 static void         echo_drv_finish(void);
 
 static ErlDrvEntry echo_drv_entry = { 
@@ -32,9 +35,9 @@ static ErlDrvEntry echo_drv_entry = {
     "echo_drv",
     echo_drv_finish,
     NULL, /* handle */
-    NULL, /* control */
+    echo_control, /* control */
     NULL, /* timeout */
-    NULL, /* outputv */
+    echo_outputv, /* outputv */
     NULL, /* ready_async */
     NULL,
     NULL,
@@ -56,6 +59,14 @@ static ErlDrvEntry echo_drv_entry = {
 
 DRIVER_INIT(echo_drv)
 {
+    char buf[10];
+    size_t bufsz = sizeof(buf);
+    char *use_outputv;
+    use_outputv = (erl_drv_getenv("ECHO_DRV_USE_OUTPUTV", buf, &bufsz) == 0
+		   ? buf
+		   : "false");
+    if (strcmp(use_outputv, "true") != 0)
+	echo_drv_entry.outputv = NULL;
     return &echo_drv_entry;
 }
 
@@ -87,3 +98,15 @@ static void echo_drv_output(ErlDrvData drv_data, char *buf, ErlDrvSizeT len) {
 
 static void echo_drv_finish() {
 }
+
+static ErlDrvSSizeT echo_control(ErlDrvData drv_data,
+                                 unsigned int command, char *buf,
+                                 ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen)
+{
+    return 0;
+}
+
+static void echo_outputv(ErlDrvData drv_data, ErlIOVec *ev)
+{
+    return;
+}
diff --git erts/vsn.mk erts/vsn.mk
index acc50dc18..9f36dff0b 100644
--- erts/vsn.mk
+++ erts/vsn.mk
@@ -18,7 +18,7 @@
 # %CopyrightEnd%
 # 
 
-VSN = 8.3.5
+VSN = 8.3.5.1
 
 # Port number 4365 in 4.2
 # Port number 4366 in 4.3
diff --git lib/kernel/test/gen_tcp_misc_SUITE.erl lib/kernel/test/gen_tcp_misc_SUITE.erl
index 6b64c83fc..5e08a5ea6 100644
--- lib/kernel/test/gen_tcp_misc_SUITE.erl
+++ lib/kernel/test/gen_tcp_misc_SUITE.erl
@@ -52,7 +52,7 @@
 	 active_once_closed/1, send_timeout/1, send_timeout_active/1,
 	 otp_7731/1, zombie_sockets/1, otp_7816/1, otp_8102/1,
 	 wrapping_oct/0, wrapping_oct/1,
-         otp_9389/1]).
+         otp_9389/1, otp_13939/1]).
 
 %% Internal exports.
 -export([sender/3, not_owner/1, passive_sockets_server/2, priority_server/1, 
@@ -3014,3 +3014,42 @@ ok({ok,V}) -> V.
 get_hostname(Name) ->
     "@"++Host = lists:dropwhile(fun(C) -> C =/= $@ end, atom_to_list(Name)),
     Host.
+
+otp_13939(doc) ->
+    ["Check that writing to a remotely closed socket doesn't block forever "
+     "when exit_on_close is false."];
+otp_13939(suite) ->
+    [];
+otp_13939(Config) when is_list(Config) ->
+    {Pid, Ref} = spawn_opt(
+        fun() ->
+            {ok, Listener} = gen_tcp:listen(0, [{exit_on_close, false}]),
+            {ok, Port} = inet:port(Listener),
+
+            spawn_link(
+                fun() ->
+                    {ok, Client} = gen_tcp:connect("localhost", Port,
+                        [{active, false}]),
+                    ok = gen_tcp:close(Client)
+                end),
+
+            {ok, Accepted} = gen_tcp:accept(Listener),
+
+            ok = gen_tcp:send(Accepted, <<0:(10*1024*1024*8)>>),
+
+            %% The bug surfaces when there's a delay between the send
+            %% operations; inet:getstat is a red herring.
+            timer:sleep(100),
+
+            {error, Code} = gen_tcp:send(Accepted, <<0:(10*1024*1024*8)>>),
+            ct:pal("gen_tcp:send returned ~p~n", [Code])
+        end, [link, monitor]),
+
+    receive
+        {'DOWN', Ref, process, Pid, normal} ->
+            ok
+    after 1000 ->
+        demonitor(Ref, [flush]),
+        exit(Pid, normal),
+        ct:fail("Server process blocked on send.")
+    end.
diff --git otp_versions.table otp_versions.table
index 73f6db55e..d3b230efe 100644
--- otp_versions.table
+++ otp_versions.table
@@ -1,3 +1,4 @@
+OTP-19.3.6.1 : erts-8.3.5.1 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 inets-6.3.9 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 ssl-8.1.3 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 xmerl-1.3.14 :
 OTP-19.3.6 : erts-8.3.5 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 inets-6.3.9 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 ssl-8.1.3 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 xmerl-1.3.14 :
 OTP-19.3.5 : erts-8.3.4 xmerl-1.3.14 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 inets-6.3.9 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 ssl-8.1.3 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 :
 OTP-19.3.4 : inets-6.3.9 ssl-8.1.3 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 erts-8.3.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 xmerl-1.3.13 :
@@ -9,6 +10,7 @@ OTP-19.2.3 : erts-8.2.2 inets-6.3.5 # asn1-4.0.4 common_test-1.13 compiler-7.0.3
 OTP-19.2.2 : mnesia-4.14.3 # asn1-4.0.4 common_test-1.13 compiler-7.0.3 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.2 debugger-4.2.1 dialyzer-3.0.3 diameter-1.12.1 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.2 erts-8.2.1 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.3 ic-4.4.2 inets-6.3.4 jinterface-1.7.1 kernel-5.1.1 megaco-3.18.1 observer-2.3 odbc-2.12 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.3 reltool-0.7.2 runtime_tools-1.11 sasl-3.0.2 snmp-5.2.4 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 typer-0.9.11 wx-1.8 xmerl-1.3.12 :
 OTP-19.2.1 : erts-8.2.1 # asn1-4.0.4 common_test-1.13 compiler-7.0.3 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.2 debugger-4.2.1 dialyzer-3.0.3 diameter-1.12.1 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.2 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.3 ic-4.4.2 inets-6.3.4 jinterface-1.7.1 kernel-5.1.1 megaco-3.18.1 mnesia-4.14.2 observer-2.3 odbc-2.12 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.3 reltool-0.7.2 runtime_tools-1.11 sasl-3.0.2 snmp-5.2.4 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 typer-0.9.11 wx-1.8 xmerl-1.3.12 :
 OTP-19.2 : common_test-1.13 compiler-7.0.3 crypto-3.7.2 dialyzer-3.0.3 edoc-0.8.1 erl_docgen-0.6.1 erl_interface-3.9.2 erts-8.2 eunit-2.3.2 hipe-3.15.3 inets-6.3.4 kernel-5.1.1 mnesia-4.14.2 observer-2.3 odbc-2.12 parsetools-2.1.4 public_key-1.3 runtime_tools-1.11 sasl-3.0.2 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 wx-1.8 # asn1-4.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 debugger-4.2.1 diameter-1.12.1 eldap-1.2.2 et-1.6 gs-1.6.2 ic-4.4.2 jinterface-1.7.1 megaco-3.18.1 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 percept-0.9 reltool-0.7.2 snmp-5.2.4 typer-0.9.11 xmerl-1.3.12 :
+OTP-19.1.6.1 : erts-8.1.1.1 # asn1-4.0.4 common_test-1.12.3 compiler-7.0.2 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.1 debugger-4.2.1 dialyzer-3.0.2 diameter-1.12.1 edoc-0.8 eldap-1.2.2 erl_docgen-0.6 erl_interface-3.9.1 et-1.6 eunit-2.3.1 gs-1.6.2 hipe-3.15.2 ic-4.4.2 inets-6.3.3 jinterface-1.7.1 kernel-5.1 megaco-3.18.1 mnesia-4.14.1 observer-2.2.2 odbc-2.11.3 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.3 percept-0.9 public_key-1.2 reltool-0.7.2 runtime_tools-1.10.1 sasl-3.0.1 snmp-5.2.4 ssh-4.3.6 ssl-8.0.3 stdlib-3.1 syntax_tools-2.1 tools-2.8.6 typer-0.9.11 wx-1.7.1 xmerl-1.3.12 :
 OTP-19.1.6 : erts-8.1.1 # asn1-4.0.4 common_test-1.12.3 compiler-7.0.2 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.1 debugger-4.2.1 dialyzer-3.0.2 diameter-1.12.1 edoc-0.8 eldap-1.2.2 erl_docgen-0.6 erl_interface-3.9.1 et-1.6 eunit-2.3.1 gs-1.6.2 hipe-3.15.2 ic-4.4.2 inets-6.3.3 jinterface-1.7.1 kernel-5.1 megaco-3.18.1 mnesia-4.14.1 observer-2.2.2 odbc-2.11.3 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.3 percept-0.9 public_key-1.2 reltool-0.7.2 runtime_tools-1.10.1 sasl-3.0.1 snmp-5.2.4 ssh-4.3.6 ssl-8.0.3 stdlib-3.1 syntax_tools-2.1 tools-2.8.6 typer-0.9.11 wx-1.7.1 xmerl-1.3.12 :
 OTP-19.1.5 : ssh-4.3.6 # asn1-4.0.4 common_test-1.12.3 compiler-7.0.2 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.1 debugger-4.2.1 dialyzer-3.0.2 diameter-1.12.1 edoc-0.8 eldap-1.2.2 erl_docgen-0.6 erl_interface-3.9.1 erts-8.1 et-1.6 eunit-2.3.1 gs-1.6.2 hipe-3.15.2 ic-4.4.2 inets-6.3.3 jinterface-1.7.1 kernel-5.1 megaco-3.18.1 mnesia-4.14.1 observer-2.2.2 odbc-2.11.3 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.3 percept-0.9 public_key-1.2 reltool-0.7.2 runtime_tools-1.10.1 sasl-3.0.1 snmp-5.2.4 ssl-8.0.3 stdlib-3.1 syntax_tools-2.1 tools-2.8.6 typer-0.9.11 wx-1.7.1 xmerl-1.3.12 :
 OTP-19.1.4 : ssh-4.3.5 # asn1-4.0.4 common_test-1.12.3 compiler-7.0.2 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.1 debugger-4.2.1 dialyzer-3.0.2 diameter-1.12.1 edoc-0.8 eldap-1.2.2 erl_docgen-0.6 erl_interface-3.9.1 erts-8.1 et-1.6 eunit-2.3.1 gs-1.6.2 hipe-3.15.2 ic-4.4.2 inets-6.3.3 jinterface-1.7.1 kernel-5.1 megaco-3.18.1 mnesia-4.14.1 observer-2.2.2 odbc-2.11.3 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.3 percept-0.9 public_key-1.2 reltool-0.7.2 runtime_tools-1.10.1 sasl-3.0.1 snmp-5.2.4 ssl-8.0.3 stdlib-3.1 syntax_tools-2.1 tools-2.8.6 typer-0.9.11 wx-1.7.1 xmerl-1.3.12 :
