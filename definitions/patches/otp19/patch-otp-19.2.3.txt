diff --git OTP_VERSION OTP_VERSION
index d16f3ea71..de5621104 100644
--- OTP_VERSION
+++ OTP_VERSION
@@ -1 +1 @@
-19.2.2
+19.2.3
diff --git erts/doc/src/notes.xml erts/doc/src/notes.xml
index d4bc81912..1d3b198f1 100644
--- erts/doc/src/notes.xml
+++ erts/doc/src/notes.xml
@@ -32,6 +32,34 @@
   <p>This document describes the changes made to the ERTS application.</p>
 
 
+<section><title>Erts 8.2.2</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    Fix bug in <c>binary_to_term</c> for binaries created by
+	    <c>term_to_binary </c> with option <c>compressed</c>. The
+	    bug can cause <c>badarg</c> exception for a valid binary
+	    when Erlang VM is linked against a <c>zlib</c> library of
+	    version 1.2.9 or newer. Bug exists since OTP 17.0.</p>
+          <p>
+	    Own Id: OTP-14159 Aux Id: ERL-340 </p>
+        </item>
+        <item>
+          <p>
+	    The driver efile_drv when opening a file now use fstat()
+	    on the open file instead of stat() before opening, if
+	    fstat() exists. This avoids a race when the file happens
+	    to change between stat() and open().</p>
+          <p>
+	    Own Id: OTP-14184 Aux Id: seq-13266 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Erts 8.2.1</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git erts/emulator/beam/external.c erts/emulator/beam/external.c
index beed84757..587c29e3b 100644
--- erts/emulator/beam/external.c
+++ erts/emulator/beam/external.c
@@ -1222,6 +1222,7 @@ typedef struct B2TContext_t {
     } u;
 } B2TContext;
 
+static B2TContext* b2t_export_context(Process*, B2TContext* src);
 
 static uLongf binary2term_uncomp_size(byte* data, Sint size)
 {
@@ -1254,7 +1255,7 @@ static uLongf binary2term_uncomp_size(byte* data, Sint size)
 
 static ERTS_INLINE int
 binary2term_prepare(ErtsBinary2TermState *state, byte *data, Sint data_size,
-		    B2TContext* ctx)
+		    B2TContext** ctxp, Process* p)
 {
     byte *bytes = data;
     Sint size = data_size;
@@ -1268,8 +1269,8 @@ binary2term_prepare(ErtsBinary2TermState *state, byte *data, Sint data_size,
     size--;
     if (size < 5 || *bytes != COMPRESSED) {
 	state->extp = bytes;
-        if (ctx)
-	    ctx->state = B2TSizeInit;
+        if (ctxp)
+	    (*ctxp)->state = B2TSizeInit;
     }
     else  {
 	uLongf dest_len = (Uint32) get_int32(bytes+1);
@@ -1286,16 +1287,26 @@ binary2term_prepare(ErtsBinary2TermState *state, byte *data, Sint data_size,
                 return -1;
 	    }
 	    state->extp = erts_alloc(ERTS_ALC_T_EXT_TERM_DATA, dest_len);
-            ctx->reds -= dest_len;
+            if (ctxp)
+                (*ctxp)->reds -= dest_len;
 	}
 	state->exttmp = 1;
-        if (ctx) {
+        if (ctxp) {
+            /*
+             * Start decompression by exporting trap context
+             * so we don't have to deal with deep-copying z_stream.
+             */
+            B2TContext* ctx = b2t_export_context(p, *ctxp);
+            ASSERT(state = &(*ctxp)->b2ts);
+            state = &ctx->b2ts;
+
 	    if (erl_zlib_inflate_start(&ctx->u.uc.stream, bytes, size) != Z_OK)
 		return -1;
 
 	    ctx->u.uc.dbytes = state->extp;
 	    ctx->u.uc.dleft = dest_len;
 	    ctx->state = B2TUncompressChunk;
+            *ctxp = ctx;
         }
 	else {
 	    uLongf dlen = dest_len;
@@ -1339,7 +1350,7 @@ erts_binary2term_prepare(ErtsBinary2TermState *state, byte *data, Sint data_size
 {
     Sint res;
 
-    if (binary2term_prepare(state, data, data_size, NULL) < 0 ||
+    if (binary2term_prepare(state, data, data_size, NULL, NULL) < 0 ||
         (res=decoded_size(state->extp, state->extp + state->extsize, 0, NULL)) < 0) {
 
         if (state->exttmp)
@@ -1485,7 +1496,7 @@ static BIF_RETTYPE binary_to_term_int(Process* p, Uint32 flags, Eterm bin, Binar
             if (ctx->aligned_alloc) {
                 ctx->reds -= bin_size / 8;
             }
-            if (binary2term_prepare(&ctx->b2ts, bytes, bin_size, ctx) < 0) {
+            if (binary2term_prepare(&ctx->b2ts, bytes, bin_size, &ctx, p) < 0) {
 		ctx->state = B2TBadArg;
 	    }
             break;
diff --git erts/emulator/drivers/unix/unix_efile.c erts/emulator/drivers/unix/unix_efile.c
index bfe0807df..3ff68a885 100644
--- erts/emulator/drivers/unix/unix_efile.c
+++ erts/emulator/drivers/unix/unix_efile.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 1997-2016. All Rights Reserved.
+ * Copyright Ericsson AB 1997-2017. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,11 +79,10 @@
  * Macros for testing file types.
  */
 
-#define ISDIR(st) (((st).st_mode & S_IFMT) == S_IFDIR)
-#define ISREG(st) (((st).st_mode & S_IFMT) == S_IFREG)
-#define ISDEV(st) \
-  (((st).st_mode&S_IFMT) == S_IFCHR || ((st).st_mode&S_IFMT) == S_IFBLK)
-#define ISLNK(st) (((st).st_mode & S_IFLNK) == S_IFLNK)
+#define ISDIR(st) (S_ISDIR((st).st_mode))
+#define ISREG(st) (S_ISREG((st).st_mode))
+#define ISDEV(st) (S_ISCHR((st).st_mode) || S_ISBLK((st).st_mode))
+#define ISLNK(st) (S_ISLNK((st).st_mode))
 #ifdef NO_UMASK
 #define FILE_MODE 0644
 #define DIR_MODE  0755
@@ -366,33 +365,6 @@ efile_openfile(Efile_error* errInfo,	/* Where to return error codes. */
     int fd;
     int mode;			/* Open mode. */
 
-    if (stat(name, &statbuf) < 0) {
-	/* statbuf is undefined: if the caller depends on it,
-	   i.e. invoke_read_file(), fail the call immediately */
-	if (pSize && flags == EFILE_MODE_READ)
-	    return check_error(-1, errInfo);
-    } else if (!ISREG(statbuf)) {
-	/*
-	 * For UNIX only, here is some ugly code to allow
-	 * /dev/null to be opened as a file.
-	 *
-	 * Assumption: The i-node number for /dev/null cannot be zero.
-	 */
-	static ino_t dev_null_ino = 0;
-
-	if (dev_null_ino == 0) {
-	    struct stat nullstatbuf;
-	    
-	    if (stat("/dev/null", &nullstatbuf) >= 0) {
-		dev_null_ino = nullstatbuf.st_ino;
-	    }
-	}
-	if (!(dev_null_ino && statbuf.st_ino == dev_null_ino)) {
-	    errno = EISDIR;
-	    return check_error(-1, errInfo);
-	}
-    }
-
     switch (flags & (EFILE_MODE_READ|EFILE_MODE_WRITE)) {
     case EFILE_MODE_READ:
 	mode = O_RDONLY;
@@ -411,16 +383,13 @@ efile_openfile(Efile_error* errInfo,	/* Where to return error codes. */
 	return check_error(-1, errInfo);
     }
 
-
     if (flags & EFILE_MODE_APPEND) {
 	mode &= ~O_TRUNC;
 	mode |= O_APPEND;
     }
-
     if (flags & EFILE_MODE_EXCL) {
 	mode |= O_EXCL;
     }
-
     if (flags & EFILE_MODE_SYNC) {
 #ifdef O_SYNC
 	mode |= O_SYNC;
@@ -430,15 +399,49 @@ efile_openfile(Efile_error* errInfo,	/* Where to return error codes. */
 #endif
     }
 
-    fd = open(name, mode, FILE_MODE);
+#ifdef HAVE_FSTAT
+    while (((fd = open(name, mode, FILE_MODE)) < 0) && (errno == EINTR));
+    if (!check_error(fd, errInfo)) return 0;
+#endif
 
-    if (!check_error(fd, errInfo))
-	return 0;
+    if (
+#ifdef HAVE_FSTAT
+        fstat(fd, &statbuf) < 0
+#else
+        stat(name, &statbuf) < 0
+#endif
+        ) {
+        /* statbuf is undefined: if the caller depends on it,
+           i.e. invoke_read_file(), fail the call immediately */
+        if (pSize && flags == EFILE_MODE_READ) {
+            check_error(-1, errInfo);
+#ifdef HAVE_FSTAT
+            efile_closefile(fd);
+#endif
+            return 0;
+        }
+    }
+    else if (! ISREG(statbuf)) {
+        struct stat nullstatbuf;
+	/*
+	 * For UNIX only, here is some ugly code to allow
+	 * /dev/null to be opened as a file.
+	 */
+        if ( (stat("/dev/null", &nullstatbuf) < 0)
+             || (statbuf.st_ino != nullstatbuf.st_ino)
+             || (statbuf.st_dev != nullstatbuf.st_dev) ) {
+	    errno = EISDIR;
+	    return check_error(-1, errInfo);
+        }
+    }
+
+#ifndef HAVE_FSTAT
+    while (((fd = open(name, mode, FILE_MODE)) < 0) && (errno == EINTR));
+    if (!check_error(fd, errInfo)) return 0;
+#endif
 
     *pfd = fd;
-    if (pSize) {
-	*pSize = statbuf.st_size;
-    }
+    if (pSize) *pSize = statbuf.st_size;
     return 1;
 }
 
@@ -460,7 +463,7 @@ efile_may_openfile(Efile_error* errInfo, char *name) {
 void
 efile_closefile(int fd)
 {
-    close(fd);
+    while((close(fd) < 0) && (errno == EINTR));
 }
 
 int
diff --git erts/vsn.mk erts/vsn.mk
index 028b11406..a0a991f5a 100644
--- erts/vsn.mk
+++ erts/vsn.mk
@@ -18,7 +18,7 @@
 # %CopyrightEnd%
 # 
 
-VSN = 8.2.1
+VSN = 8.2.2
 
 # Port number 4365 in 4.2
 # Port number 4366 in 4.3
diff --git lib/inets/doc/src/notes.xml lib/inets/doc/src/notes.xml
index 398fc7e5b..5c3b5a2d3 100644
--- lib/inets/doc/src/notes.xml
+++ lib/inets/doc/src/notes.xml
@@ -33,7 +33,22 @@
     <file>notes.xml</file>
   </header>
   
-  <section><title>Inets 6.3.4</title>
+  <section><title>Inets 6.3.5</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    Correct misstakes in ftp client introduced in inets-6.3.4</p>
+          <p>
+	    Own Id: OTP-14203 Aux Id: OTP-13982 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
+<section><title>Inets 6.3.4</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
       <list>
diff --git lib/inets/src/ftp/ftp.erl lib/inets/src/ftp/ftp.erl
index 911f5b71a..23d648329 100644
--- lib/inets/src/ftp/ftp.erl
+++ lib/inets/src/ftp/ftp.erl
@@ -1477,10 +1477,7 @@ handle_info({Trpt, Socket, Data}, #state{dsock = {Trpt,Socket}} = State0) when T
 handle_info({Cls, Socket}, #state{dsock = {Trpt,Socket},
 				  caller = {recv_file, Fd}} = State)
   when {Cls,Trpt}=={tcp_closed,tcp} ; {Cls,Trpt}=={ssl_closed,ssl} ->
-    case file_close(Fd) of
-	ok -> ok;
-	{error,einval} -> ok
-    end,
+    file_close(Fd),
     progress_report({transfer_size, 0}, State),
     activate_ctrl_connection(State),
     {noreply, State#state{dsock = undefined, data = <<>>}};
@@ -2066,10 +2063,7 @@ handle_ctrl_result({pos_prel, _}, #state{caller = {recv_file, _}} = State0) ->
     end;
 
 handle_ctrl_result({Status, _}, #state{caller = {recv_file, Fd}} = State) ->
-    case file_close(Fd) of
-	ok -> ok;
-	{error, einval} -> ok
-    end,
+    file_close(Fd),
     close_data_connection(State),
     ctrl_result_response(Status, State#state{dsock = undefined}, 
 			 {error, epath});
@@ -2345,7 +2339,7 @@ accept_data_connection(#state{mode = passive} = State) ->
 send_ctrl_message(_S=#state{csock = Socket, verbose = Verbose}, Message) ->
     verbose(lists:flatten(Message),Verbose,send),
     ?DBG('<--ctrl ~p ---- ~s~p~n',[Socket,Message,_S]),
-    ok = send_message(Socket, Message).
+    _ = send_message(Socket, Message).
 
 send_data_message(_S=#state{dsock = Socket}, Message) ->
     ?DBG('<==data ~p ==== ~s~n~p~n',[Socket,Message,_S]),
@@ -2366,37 +2360,44 @@ send_message({tcp, Socket}, Message) ->
 send_message({ssl, Socket}, Message) ->
     ssl:send(Socket, Message).
 
-activate_ctrl_connection(#state{csock = Socket, ctrl_data = {<<>>, _, _}}) ->
-    ok = activate_connection(Socket);
-activate_ctrl_connection(#state{csock = Socket}) ->
-    ok = activate_connection(Socket),
+activate_ctrl_connection(#state{csock = CSock, ctrl_data = {<<>>, _, _}}) ->
+    activate_connection(CSock);
+activate_ctrl_connection(#state{csock = CSock}) ->
+    activate_connection(CSock),
     %% We have already received at least part of the next control message,
     %% that has been saved in ctrl_data, process this first.
-    self() ! {socket_type(Socket), unwrap_socket(Socket), <<>>},
+    self() ! {socket_type(CSock), unwrap_socket(CSock), <<>>},
     ok.
 
+activate_data_connection(#state{dsock = DSock} = State) ->
+    activate_connection(DSock),
+    State.
+
+activate_connection(Socket) ->
+    ignore_return_value(
+      case socket_type(Socket) of
+          tcp -> inet:setopts(unwrap_socket(Socket), [{active, once}]);
+          ssl -> ssl:setopts(unwrap_socket(Socket), [{active, once}])
+      end).
+
+
+ignore_return_value(_) -> ok.
+
 unwrap_socket({tcp,Socket}) -> Socket;
 unwrap_socket({ssl,Socket}) -> Socket.
     
 socket_type({tcp,_Socket}) -> tcp;
 socket_type({ssl,_Socket}) -> ssl.
 
-activate_data_connection(#state{dsock = Socket} = State) ->
-    ok = activate_connection(Socket),
-    State.
-
-activate_connection({tcp, Socket}) -> inet:setopts(Socket, [{active, once}]);
-activate_connection({ssl, Socket}) -> ssl:setopts(Socket, [{active, once}]).
-
 close_ctrl_connection(#state{csock = undefined}) -> ok;
 close_ctrl_connection(#state{csock = Socket}) -> close_connection(Socket).
 
 close_data_connection(#state{dsock = undefined}) -> ok;
 close_data_connection(#state{dsock = Socket}) -> close_connection(Socket).
 
-close_connection({lsock,Socket}) -> gen_tcp:close(Socket);
-close_connection({tcp, Socket}) -> gen_tcp:close(Socket);
-close_connection({ssl, Socket}) -> ssl:close(Socket).
+close_connection({lsock,Socket}) -> ignore_return_value( gen_tcp:close(Socket) );
+close_connection({tcp, Socket})  -> ignore_return_value( gen_tcp:close(Socket) );
+close_connection({ssl, Socket})  -> ignore_return_value( ssl:close(Socket) ).
 
 %%  ------------ FILE HANDLING  ----------------------------------------   
 send_file(#state{tls_upgrading_data_connection = {true, CTRL, _}} = State, Fd) ->
@@ -2408,7 +2409,7 @@ send_file(State, Fd) ->
 	    progress_report({binary, Bin}, State),
 	    send_file(State, Fd);
 	{ok, _, _} ->
-	    ok = file_close(Fd),
+	    file_close(Fd),
 	    close_data_connection(State),
 	    progress_report({transfer_size, 0}, State),
 	    activate_ctrl_connection(State),
@@ -2423,7 +2424,7 @@ file_open(File, Option) ->
   file:open(File, [raw, binary, Option]).
 
 file_close(Fd) ->
-  file:close(Fd).
+    ignore_return_value( file:close(Fd) ).
 
 file_read(Fd) ->				
     case file:read(Fd, ?FILE_BUFSIZE) of
diff --git lib/inets/vsn.mk lib/inets/vsn.mk
index eef5abd61..9591ab22e 100644
--- lib/inets/vsn.mk
+++ lib/inets/vsn.mk
@@ -19,6 +19,6 @@
 # %CopyrightEnd%
 
 APPLICATION = inets
-INETS_VSN   = 6.3.4
+INETS_VSN   = 6.3.5
 PRE_VSN     =
 APP_VSN     = "$(APPLICATION)-$(INETS_VSN)$(PRE_VSN)"
diff --git otp_versions.table otp_versions.table
index 2f3187896..dc1a48009 100644
--- otp_versions.table
+++ otp_versions.table
@@ -1,3 +1,4 @@
+OTP-19.2.3 : erts-8.2.2 inets-6.3.5 # asn1-4.0.4 common_test-1.13 compiler-7.0.3 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.2 debugger-4.2.1 dialyzer-3.0.3 diameter-1.12.1 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.2 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.3 ic-4.4.2 jinterface-1.7.1 kernel-5.1.1 megaco-3.18.1 mnesia-4.14.3 observer-2.3 odbc-2.12 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.3 reltool-0.7.2 runtime_tools-1.11 sasl-3.0.2 snmp-5.2.4 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 typer-0.9.11 wx-1.8 xmerl-1.3.12 :
 OTP-19.2.2 : mnesia-4.14.3 # asn1-4.0.4 common_test-1.13 compiler-7.0.3 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.2 debugger-4.2.1 dialyzer-3.0.3 diameter-1.12.1 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.2 erts-8.2.1 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.3 ic-4.4.2 inets-6.3.4 jinterface-1.7.1 kernel-5.1.1 megaco-3.18.1 observer-2.3 odbc-2.12 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.3 reltool-0.7.2 runtime_tools-1.11 sasl-3.0.2 snmp-5.2.4 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 typer-0.9.11 wx-1.8 xmerl-1.3.12 :
 OTP-19.2.1 : erts-8.2.1 # asn1-4.0.4 common_test-1.13 compiler-7.0.3 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.2 debugger-4.2.1 dialyzer-3.0.3 diameter-1.12.1 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.2 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.3 ic-4.4.2 inets-6.3.4 jinterface-1.7.1 kernel-5.1.1 megaco-3.18.1 mnesia-4.14.2 observer-2.3 odbc-2.12 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.3 reltool-0.7.2 runtime_tools-1.11 sasl-3.0.2 snmp-5.2.4 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 typer-0.9.11 wx-1.8 xmerl-1.3.12 :
 OTP-19.2 : common_test-1.13 compiler-7.0.3 crypto-3.7.2 dialyzer-3.0.3 edoc-0.8.1 erl_docgen-0.6.1 erl_interface-3.9.2 erts-8.2 eunit-2.3.2 hipe-3.15.3 inets-6.3.4 kernel-5.1.1 mnesia-4.14.2 observer-2.3 odbc-2.12 parsetools-2.1.4 public_key-1.3 runtime_tools-1.11 sasl-3.0.2 ssh-4.4 ssl-8.1 stdlib-3.2 syntax_tools-2.1.1 tools-2.9 wx-1.8 # asn1-4.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 debugger-4.2.1 diameter-1.12.1 eldap-1.2.2 et-1.6 gs-1.6.2 ic-4.4.2 jinterface-1.7.1 megaco-3.18.1 orber-3.8.2 os_mon-2.4.1 otp_mibs-1.1.1 percept-0.9 reltool-0.7.2 snmp-5.2.4 typer-0.9.11 xmerl-1.3.12 :
