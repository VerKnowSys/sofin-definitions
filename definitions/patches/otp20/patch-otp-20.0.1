diff --git OTP_VERSION OTP_VERSION
index 9a7c1e503..fcc01369a 100644
--- OTP_VERSION
+++ OTP_VERSION
@@ -1 +1 @@
-20.0
+20.0.1
diff --git erts/doc/src/erlang.xml erts/doc/src/erlang.xml
index 687ff38cb..105734d5b 100644
--- erts/doc/src/erlang.xml
+++ erts/doc/src/erlang.xml
@@ -6483,6 +6483,9 @@ lists:map(
         <p>This is the sum of the runtime for all threads
           in the Erlang runtime system and can therefore be greater
           than the wall clock time.</p>
+          <warning><p>This value might wrap due to limitations in the
+          underlying functionality provided by the operating system
+          that is used.</p></warning>
         <p>Example:</p>
         <pre>
 > <input>statistics(runtime).</input>
diff --git erts/doc/src/notes.xml erts/doc/src/notes.xml
index 4d7e57873..7003564f9 100644
--- erts/doc/src/notes.xml
+++ erts/doc/src/notes.xml
@@ -31,6 +31,43 @@
   </header>
   <p>This document describes the changes made to the ERTS application.</p>
 
+<section><title>Erts 9.0.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    Fixed a bug in gen_tcp:send where it never returned when
+	    repeatedly called on a remotely closed TCP socket.</p>
+          <p>
+	    Own Id: OTP-13939 Aux Id: ERL-193 </p>
+        </item>
+        <item>
+          <p>
+	    Fixed segfault that could happen during cleanup of
+	    aborted erlang:port_command/3 calls. A port_command is
+	    aborted if the port is closed at the same time as the
+	    port_command was issued. This bug was introduced in
+	    erts-8.0.</p>
+          <p>
+	    Own Id: OTP-14481</p>
+        </item>
+        <item>
+          <p>
+	    Fixed implementation of <c>statistics(wall_clock)</c> and
+	    <c>statistics(runtime)</c> so that values do not
+	    unnecessarily wrap due to the emulator. Note that the
+	    values returned by <c>statistics(runtime)</c> may still
+	    wrap due to limitations in the underlying functionality
+	    provided by the operating system.</p>
+          <p>
+	    Own Id: OTP-14484</p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Erts 9.0</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git erts/emulator/beam/erl_bif_info.c erts/emulator/beam/erl_bif_info.c
index e2773475b..96f9b284b 100644
--- erts/emulator/beam/erl_bif_info.c
+++ erts/emulator/beam/erl_bif_info.c
@@ -3544,24 +3544,32 @@ BIF_RETTYPE statistics_1(BIF_ALIST_1)
 	res = TUPLE2(hp, b1, b2); 
 	BIF_RET(res);
     } else if (BIF_ARG_1 == am_runtime) {
-	UWord u1, u2, dummy;
+	ErtsMonotonicTime u1, u2;
 	Eterm b1, b2;
-	elapsed_time_both(&u1,&dummy,&u2,&dummy);
-	b1 = erts_make_integer(u1,BIF_P);
-	b2 = erts_make_integer(u2,BIF_P);
-	hp = HAlloc(BIF_P,3);
+        Uint hsz;
+	elapsed_time_both(&u1, NULL, &u2, NULL);
+        hsz = 3; /* 2-tuple */
+        (void) erts_bld_monotonic_time(NULL, &hsz, u1);
+        (void) erts_bld_monotonic_time(NULL, &hsz, u2);
+	hp = HAlloc(BIF_P, hsz);
+        b1 = erts_bld_monotonic_time(&hp, NULL, u1);
+        b2 = erts_bld_monotonic_time(&hp, NULL, u2);
 	res = TUPLE2(hp, b1, b2);
 	BIF_RET(res);
     } else if (BIF_ARG_1 ==  am_run_queue) {
 	res = erts_run_queues_len(NULL, 1, 0, 0);
 	BIF_RET(make_small(res));
     } else if (BIF_ARG_1 == am_wall_clock) {
-	UWord w1, w2;
+	ErtsMonotonicTime w1, w2;
 	Eterm b1, b2;
+        Uint hsz;
 	wall_clock_elapsed_time_both(&w1, &w2);
-	b1 = erts_make_integer((Uint) w1,BIF_P);
-	b2 = erts_make_integer((Uint) w2,BIF_P);
-	hp = HAlloc(BIF_P,3);
+        hsz = 3; /* 2-tuple */
+        (void) erts_bld_monotonic_time(NULL, &hsz, w1);
+        (void) erts_bld_monotonic_time(NULL, &hsz, w2);
+	hp = HAlloc(BIF_P, hsz);
+        b1 = erts_bld_monotonic_time(&hp, NULL, w1);
+        b2 = erts_bld_monotonic_time(&hp, NULL, w2);
 	res = TUPLE2(hp, b1, b2);
 	BIF_RET(res);
     } else if (BIF_ARG_1 == am_io) {
diff --git erts/emulator/beam/erl_port_task.c erts/emulator/beam/erl_port_task.c
index a044de3fe..1ab1e4725 100644
--- erts/emulator/beam/erl_port_task.c
+++ erts/emulator/beam/erl_port_task.c
@@ -852,10 +852,11 @@ schedule_port_task_handle_list_free(ErtsPortTaskHandleList *pthlp)
 }
 
 static ERTS_INLINE void
-abort_nosuspend_task(Port *pp,
-		     ErtsPortTaskType type,
-		     ErtsPortTaskTypeData *tdp,
-		     int bpq_data)
+abort_signal_task(Port *pp,
+                  int abort_type,
+                  ErtsPortTaskType type,
+                  ErtsPortTaskTypeData *tdp,
+                  int bpq_data)
 {
 
     ASSERT(type == ERTS_PORT_TASK_PROC_SIG);
@@ -863,18 +864,28 @@ abort_nosuspend_task(Port *pp,
     if (!bpq_data)
 	tdp->psig.callback(NULL,
 			   ERTS_PORT_SFLG_INVALID,
-			   ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND,
+			   abort_type,
 			   &tdp->psig.data);
     else {
 	ErlDrvSizeT size = erts_proc2port_sig_command_data_size(&tdp->psig.data);
 	tdp->psig.callback(NULL,
 			   ERTS_PORT_SFLG_INVALID,
-			   ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND,
+			   abort_type,
 			   &tdp->psig.data);
 	aborted_proc2port_data(pp, size);
     }
 }
 
+
+static ERTS_INLINE void
+abort_nosuspend_task(Port *pp,
+		     ErtsPortTaskType type,
+		     ErtsPortTaskTypeData *tdp,
+		     int bpq_data)
+{
+    abort_signal_task(pp, ERTS_PROC2PORT_SIG_ABORT_NOSUSPEND, type, tdp, bpq_data);
+}
+
 static ErtsPortTaskHandleList *
 get_free_nosuspend_handles(Port *pp)
 {
@@ -1613,8 +1624,9 @@ abort_nosuspend:
 
     ASSERT(ns_pthlp);
     erts_free(ERTS_ALC_T_PT_HNDL_LIST, ns_pthlp);
-    if (ptp)
-	port_task_free(ptp);
+
+    ASSERT(ptp);
+    port_task_free(ptp);
 
     return 0;
 
@@ -1625,12 +1637,15 @@ fail:
 	erts_port_dec_refc(pp);
 #endif
 
+    if (ptp) {
+        abort_signal_task(pp, ERTS_PROC2PORT_SIG_ABORT,
+                          ptp->type, &ptp->u.alive.td, 0);
+	port_task_free(ptp);
+    }
+
     if (ns_pthlp)
 	erts_free(ERTS_ALC_T_PT_HNDL_LIST, ns_pthlp);
 
-    if (ptp)
-	port_task_free(ptp);
-
     return -1;
 }
 
diff --git erts/emulator/beam/erl_sched_spec_pre_alloc.c erts/emulator/beam/erl_sched_spec_pre_alloc.c
index cab4bd73d..96238318c 100644
--- erts/emulator/beam/erl_sched_spec_pre_alloc.c
+++ erts/emulator/beam/erl_sched_spec_pre_alloc.c
@@ -161,7 +161,7 @@ enqueue_remote_managed_thread(erts_sspa_chunk_header_t *chdr,
 	    if ((i & 1) == 0)
 		itmp = itmp2;
 	    else {
-		enq = (erts_sspa_blk_t *) itmp;
+		enq = (erts_sspa_blk_t *) itmp2;
 		itmp = erts_atomic_read_acqb(&enq->next_atmc);
 		ASSERT(itmp != ERTS_AINT_NULL);
 	    }
diff --git erts/emulator/beam/erl_time_sup.c erts/emulator/beam/erl_time_sup.c
index 3084a8db7..0421adb40 100644
--- erts/emulator/beam/erl_time_sup.c
+++ erts/emulator/beam/erl_time_sup.c
@@ -1286,56 +1286,62 @@ erts_finalize_time_offset(void)
 /* info functions */
 
 void 
-elapsed_time_both(UWord *ms_user, UWord *ms_sys, 
-		  UWord *ms_user_diff, UWord *ms_sys_diff)
+elapsed_time_both(ErtsMonotonicTime *ms_user, ErtsMonotonicTime *ms_sys, 
+		  ErtsMonotonicTime *ms_user_diff, ErtsMonotonicTime *ms_sys_diff)
 {
-    UWord prev_total_user, prev_total_sys;
-    UWord total_user, total_sys;
+    ErtsMonotonicTime prev_total_user, prev_total_sys;
+    ErtsMonotonicTime total_user, total_sys;
     SysTimes now;
 
     sys_times(&now);
-    total_user = (now.tms_utime * 1000) / SYS_CLK_TCK;
-    total_sys = (now.tms_stime * 1000) / SYS_CLK_TCK;
+    total_user = (ErtsMonotonicTime) ((now.tms_utime * 1000) / SYS_CLK_TCK);
+    total_sys = (ErtsMonotonicTime) ((now.tms_stime * 1000) / SYS_CLK_TCK);
 
     if (ms_user != NULL)
 	*ms_user = total_user;
     if (ms_sys != NULL)
 	*ms_sys = total_sys;
 
-    erts_smp_mtx_lock(&erts_timeofday_mtx);
+    if (ms_user_diff || ms_sys_diff) {
+        erts_smp_mtx_lock(&erts_timeofday_mtx);
     
-    prev_total_user = (t_start.tms_utime * 1000) / SYS_CLK_TCK;
-    prev_total_sys = (t_start.tms_stime * 1000) / SYS_CLK_TCK;
-    t_start = now;
+        prev_total_user = (ErtsMonotonicTime) ((t_start.tms_utime * 1000) / SYS_CLK_TCK);
+        prev_total_sys = (ErtsMonotonicTime) ((t_start.tms_stime * 1000) / SYS_CLK_TCK);
+        t_start = now;
     
-    erts_smp_mtx_unlock(&erts_timeofday_mtx);
+        erts_smp_mtx_unlock(&erts_timeofday_mtx);
 
-    if (ms_user_diff != NULL)
-	*ms_user_diff = total_user - prev_total_user;
+        if (ms_user_diff != NULL)
+            *ms_user_diff = total_user - prev_total_user;
 	  
-    if (ms_sys_diff != NULL)
-	*ms_sys_diff = total_sys - prev_total_sys;
+        if (ms_sys_diff != NULL)
+            *ms_sys_diff = total_sys - prev_total_sys;
+    }
 }
 
 
 /* wall clock routines */
 
 void 
-wall_clock_elapsed_time_both(UWord *ms_total, UWord *ms_diff)
+wall_clock_elapsed_time_both(ErtsMonotonicTime *ms_total, ErtsMonotonicTime *ms_diff)
 {
     ErtsMonotonicTime now, elapsed;
 
-    erts_smp_mtx_lock(&erts_timeofday_mtx);
-
     now = time_sup.r.o.get_time();
     update_last_mtime(NULL, now);
 
     elapsed = ERTS_MONOTONIC_TO_MSEC(now);
-    *ms_total = (UWord) elapsed;
-    *ms_diff = (UWord) (elapsed - prev_wall_clock_elapsed);
-    prev_wall_clock_elapsed = elapsed;
 
-    erts_smp_mtx_unlock(&erts_timeofday_mtx);
+    *ms_total = elapsed;
+
+    if (ms_diff) {
+        erts_smp_mtx_lock(&erts_timeofday_mtx);
+
+        *ms_diff = elapsed - prev_wall_clock_elapsed;
+        prev_wall_clock_elapsed = elapsed;
+
+        erts_smp_mtx_unlock(&erts_timeofday_mtx);
+    }
 }
 
 /* get current time */
diff --git erts/emulator/beam/erl_utils.h erts/emulator/beam/erl_utils.h
index 07cf4f690..3d28b0575 100644
--- erts/emulator/beam/erl_utils.h
+++ erts/emulator/beam/erl_utils.h
@@ -131,6 +131,7 @@ Eterm erts_bld_uint(Uint **hpp, Uint *szp, Uint ui);
 Eterm erts_bld_uword(Uint **hpp, Uint *szp, UWord uw);
 Eterm erts_bld_uint64(Uint **hpp, Uint *szp, Uint64 ui64);
 Eterm erts_bld_sint64(Uint **hpp, Uint *szp, Sint64 si64);
+#define erts_bld_monotonic_time erts_bld_sint64
 Eterm erts_bld_cons(Uint **hpp, Uint *szp, Eterm car, Eterm cdr);
 Eterm erts_bld_tuple(Uint **hpp, Uint *szp, Uint arity, ...);
 #define erts_bld_tuple2(H,S,E1,E2) erts_bld_tuple(H,S,2,E1,E2)
diff --git erts/emulator/beam/io.c erts/emulator/beam/io.c
index d25e53ada..75545df80 100644
--- erts/emulator/beam/io.c
+++ erts/emulator/beam/io.c
@@ -1968,7 +1968,6 @@ int
 erts_port_output_async(Port *prt, Eterm from, Eterm list)
 {
 
-    ErtsPortOpResult res;
     ErtsProc2PortSigData *sigdp;
     erts_driver_t *drv = prt->drv_ptr;
     size_t size;
@@ -2102,26 +2101,18 @@ erts_port_output_async(Port *prt, Eterm from, Eterm list)
 	sigdp->u.output.size = size;
 	port_sig_callback = port_sig_output;
     }
-    sigdp->flags = 0;
     ns_pthp = NULL;
     task_flags = 0;
 
-    res = erts_schedule_proc2port_signal(NULL,
-					 prt,
-					 ERTS_INVALID_PID,
-					 NULL,
-					 sigdp,
-					 task_flags,
-					 ns_pthp,
-					 port_sig_callback);
+    erts_schedule_proc2port_signal(NULL,
+                                   prt,
+                                   ERTS_INVALID_PID,
+                                   NULL,
+                                   sigdp,
+                                   task_flags,
+                                   ns_pthp,
+                                   port_sig_callback);
 
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	if (drv->outputv)
-	    cleanup_scheduled_outputv(evp, cbin);
-	else
-	    cleanup_scheduled_output(buf);
-	return 1;
-    }
     return 1;
 
 bad_value:
@@ -2554,10 +2545,6 @@ erts_port_output(Process *c_p,
 					 port_sig_callback);
 
     if (res != ERTS_PORT_OP_SCHEDULED) {
-	if (drv->outputv)
-	    cleanup_scheduled_outputv(evp, cbin);
-	else
-	    cleanup_scheduled_output(buf);
 	return res;
     }
 
@@ -2736,21 +2723,14 @@ erts_port_exit(Process *c_p,
 					   &bp->off_heap);
     }
 
-    res = erts_schedule_proc2port_signal(c_p,
-					 prt,
-					 c_p ? c_p->common.id : from,
-					 refp,
-					 sigdp,
-					 0,
-					 NULL,
-					 port_sig_exit);
-
-    if (res == ERTS_PORT_OP_DROPPED) {
-	if (bp)
-	    free_message_buffer(bp);
-    }
-
-    return res;
+    return erts_schedule_proc2port_signal(c_p,
+                                          prt,
+                                          c_p ? c_p->common.id : from,
+                                          refp,
+                                          sigdp,
+                                          0,
+                                          NULL,
+                                          port_sig_exit);
 }
 
 static ErtsPortOpResult
@@ -4930,10 +4910,9 @@ erts_port_control(Process* c_p,
 					 0,
 					 NULL,
 					 port_sig_control);
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	cleanup_scheduled_control(binp, bufp);
+    if (res != ERTS_PORT_OP_SCHEDULED)
 	return ERTS_PORT_OP_BADARG;
-    }
+
     return res;
 }
 
@@ -5223,10 +5202,9 @@ erts_port_call(Process* c_p,
 					 0,
 					 NULL,
 					 port_sig_call);
-    if (res != ERTS_PORT_OP_SCHEDULED) {
-	cleanup_scheduled_call(bufp);
+    if (res != ERTS_PORT_OP_SCHEDULED)
 	return ERTS_PORT_OP_BADARG;
-    }
+
     return res;
 }
 
diff --git erts/emulator/beam/sys.h erts/emulator/beam/sys.h
index d752ea433..b6c77794d 100644
--- erts/emulator/beam/sys.h
+++ erts/emulator/beam/sys.h
@@ -784,10 +784,10 @@ Preload* sys_preloaded(void);
 unsigned char* sys_preload_begin(Preload*);
 void sys_preload_end(Preload*);
 int sys_get_key(int);
-void elapsed_time_both(UWord *ms_user, UWord *ms_sys, 
-		       UWord *ms_user_diff, UWord *ms_sys_diff);
-void wall_clock_elapsed_time_both(UWord *ms_total, 
-				  UWord *ms_diff);
+void elapsed_time_both(ErtsMonotonicTime *ms_user, ErtsMonotonicTime *ms_sys, 
+		       ErtsMonotonicTime *ms_user_diff, ErtsMonotonicTime *ms_sys_diff);
+void wall_clock_elapsed_time_both(ErtsMonotonicTime *ms_total, 
+				  ErtsMonotonicTime *ms_diff);
 void get_time(int *hour, int *minute, int *second);
 void get_date(int *year, int *month, int *day);
 void get_localtime(int *year, int *month, int *day, 
diff --git erts/emulator/drivers/common/inet_drv.c erts/emulator/drivers/common/inet_drv.c
index 13ee935e4..fe421bfe1 100644
--- erts/emulator/drivers/common/inet_drv.c
+++ erts/emulator/drivers/common/inet_drv.c
@@ -4334,6 +4334,12 @@ static void desc_close(inet_descriptor* desc)
 	desc->event = INVALID_EVENT; /* closed by stop_select callback */
 	desc->s = INVALID_SOCKET;
 	desc->event_mask = 0;
+
+	/* mark as disconnected in case when socket is left lingering due to
+	 * {exit_on_close, false} option in gen_tcp socket creation. Next
+	 * write to socket should produce {error, enotconn} and send a
+	 * message {tcp_error,#Port<>,econnreset} */
+	desc->state &= ~INET_STATE_CONNECTED;
     }
 }
 
diff --git erts/emulator/test/port_SUITE.erl erts/emulator/test/port_SUITE.erl
index f512fa3a5..ab0b1a82b 100644
--- erts/emulator/test/port_SUITE.erl
+++ erts/emulator/test/port_SUITE.erl
@@ -86,6 +86,7 @@
     cd_relative/1,
     close_deaf_port/1,
     count_fds/1,
+    dropped_commands/1,
     dying_port/1,
     env/1,
     eof/1,
@@ -548,6 +549,45 @@ make_dying_port(Config) when is_list(Config) ->
     Command = lists:concat([PortTest, " -h0 -d -q"]),
     open_port({spawn, Command}, [stream]).
 
+%% Test that dropped port_commands work correctly.
+%% This used to cause a segfault.
+%%
+%% This testcase creates a port and then lets many processes
+%% do parallel commands to it. After a while it closes the
+%% port and we are trying to catch the race when doing a
+%% command while the port is closing.
+dropped_commands(Config) ->
+    %% Test with output callback
+    dropped_commands(Config, false, {self(), {command, "1"}}),
+    %% Test with outputv callback
+    dropped_commands(Config, true, {self(), {command, "1"}}).
+
+dropped_commands(Config, Outputv, Cmd) ->
+    Path = proplists:get_value(data_dir, Config),
+    os:putenv("ECHO_DRV_USE_OUTPUTV", atom_to_list(Outputv)),
+    ok = load_driver(Path, "echo_drv"),
+    [dropped_commands_test(Cmd) || _ <- lists:seq(1, 100)],
+    timer:sleep(100),
+    erl_ddll:unload_driver("echo_drv"),
+    ok.
+
+dropped_commands_test(Cmd) ->
+    Port = erlang:open_port({spawn_driver, "echo_drv"}, [{parallelism, true}]),
+    spawn_monitor(
+      fun() ->
+              [spawn_link(fun() -> spin(Port, Cmd) end) || _ <- lists:seq(1,8)],
+              timer:sleep(5),
+              port_close(Port),
+              timer:sleep(5),
+              exit(nok)
+      end),
+    receive _M -> timer:sleep(5) end.
+
+spin(P, Cmd) ->
+    P ! Cmd,
+    spin(P, Cmd).
+
+
 %% Tests that port program with complete path (but without any
 %% .exe extension) can be started, even if there is a file with
 %% the same name but without the extension in the same directory.
diff --git erts/emulator/test/port_SUITE_data/echo_drv.c erts/emulator/test/port_SUITE_data/echo_drv.c
index 1d39c6a00..b4370f645 100644
--- erts/emulator/test/port_SUITE_data/echo_drv.c
+++ erts/emulator/test/port_SUITE_data/echo_drv.c
@@ -18,8 +18,11 @@ typedef struct _erl_drv_data EchoDrvData;
 
 static EchoDrvData *echo_drv_start(ErlDrvPort port, char *command);
 static void         echo_drv_stop(EchoDrvData *data_p);
-static void         echo_drv_output(ErlDrvData drv_data, char *buf,
-				    ErlDrvSizeT len);
+static void         echo_drv_output(ErlDrvData drv_data, char *buf, ErlDrvSizeT len);
+static ErlDrvSSizeT echo_control(ErlDrvData drv_data,
+                                 unsigned int command, char *buf,
+                                 ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen);
+static void         echo_outputv(ErlDrvData drv_data, ErlIOVec *ev);
 static void         echo_drv_finish(void);
 
 static ErlDrvEntry echo_drv_entry = { 
@@ -32,9 +35,9 @@ static ErlDrvEntry echo_drv_entry = {
     "echo_drv",
     echo_drv_finish,
     NULL, /* handle */
-    NULL, /* control */
+    echo_control, /* control */
     NULL, /* timeout */
-    NULL, /* outputv */
+    echo_outputv, /* outputv */
     NULL, /* ready_async */
     NULL,
     NULL,
@@ -56,6 +59,14 @@ static ErlDrvEntry echo_drv_entry = {
 
 DRIVER_INIT(echo_drv)
 {
+    char buf[10];
+    size_t bufsz = sizeof(buf);
+    char *use_outputv;
+    use_outputv = (erl_drv_getenv("ECHO_DRV_USE_OUTPUTV", buf, &bufsz) == 0
+		   ? buf
+		   : "false");
+    if (strcmp(use_outputv, "true") != 0)
+	echo_drv_entry.outputv = NULL;
     return &echo_drv_entry;
 }
 
@@ -87,3 +98,15 @@ static void echo_drv_output(ErlDrvData drv_data, char *buf, ErlDrvSizeT len) {
 
 static void echo_drv_finish() {
 }
+
+static ErlDrvSSizeT echo_control(ErlDrvData drv_data,
+                                 unsigned int command, char *buf,
+                                 ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen)
+{
+    return 0;
+}
+
+static void echo_outputv(ErlDrvData drv_data, ErlIOVec *ev)
+{
+    return;
+}
diff --git erts/vsn.mk erts/vsn.mk
index 05f3b4364..c4bef03e9 100644
--- erts/vsn.mk
+++ erts/vsn.mk
@@ -18,7 +18,7 @@
 # %CopyrightEnd%
 # 
 
-VSN = 9.0
+VSN = 9.0.1
 
 # Port number 4365 in 4.2
 # Port number 4366 in 4.3
diff --git lib/common_test/doc/src/notes.xml lib/common_test/doc/src/notes.xml
index 28b2d4416..37a184616 100644
--- lib/common_test/doc/src/notes.xml
+++ lib/common_test/doc/src/notes.xml
@@ -33,6 +33,26 @@
     <file>notes.xml</file>
     </header>
 
+<section><title>Common_Test 1.15.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    In OTP-20.0, the behavior of c, make, and ct_make was
+	    changed so that in some cases the beam files by default
+	    would be written to the directory where the source files
+	    were found. This is now changed back to the old behavior
+	    so beam files are by default written to current
+	    directory.</p>
+          <p>
+	    Own Id: OTP-14489 Aux Id: ERL-438 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Common_Test 1.15</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git lib/common_test/src/ct_make.erl lib/common_test/src/ct_make.erl
index 4d66796b8..220cb0473 100644
--- lib/common_test/src/ct_make.erl
+++ lib/common_test/src/ct_make.erl
@@ -280,15 +280,47 @@ recompile(File, NoExec, Load, Opts) ->
 
 do_recompile(_File, true, _Load, _Opts) ->
     out_of_date;
-do_recompile(File, false, noload, Opts) ->
+do_recompile(File, false, Load, Opts) ->
     io:format("Recompile: ~ts\n",[File]),
-    compile:file(File, [report_errors, report_warnings, error_summary |Opts]);
-do_recompile(File, false, load, Opts) ->
-    io:format("Recompile: ~ts\n",[File]),
-    c:c(File, Opts);
-do_recompile(File, false, netload, Opts) ->
-    io:format("Recompile: ~ts\n",[File]),
-    c:nc(File, Opts).
+    case compile:file(File, [report_errors, report_warnings |Opts]) of
+        Ok when is_tuple(Ok), element(1,Ok)==ok ->
+            maybe_load(element(2,Ok), Load, Opts);
+        _Error ->
+            error
+    end.
+
+maybe_load(_Mod, noload, _Opts) ->
+    ok;
+maybe_load(Mod, Load, Opts) ->
+    %% We have compiled File with options Opts. Find out where the
+    %% output file went to, and load it.
+    case compile:output_generated(Opts) of
+        true ->
+            Dir = proplists:get_value(outdir,Opts,"."),
+            do_load(Dir, Mod, Load);
+        false ->
+            io:format("** Warning: No object file created - nothing loaded **~n"),
+            ok
+    end.
+
+do_load(Dir, Mod, load) ->
+    code:purge(Mod),
+    case code:load_abs(filename:join(Dir, Mod),Mod) of
+        {module,Mod} ->
+            {ok,Mod};
+        Other ->
+            Other
+    end;
+do_load(Dir, Mod, netload) ->
+    Obj = atom_to_list(Mod) ++ code:objfile_extension(),
+    Fname = filename:join(Dir, Obj),
+    case file:read_file(Fname) of
+        {ok,Bin} ->
+            rpc:eval_everywhere(code,load_binary,[Mod,Fname,Bin]),
+            {ok,Mod};
+        Other ->
+            Other
+    end.
 
 exists(File) ->
     case file:read_file_info(File) of
diff --git lib/common_test/vsn.mk lib/common_test/vsn.mk
index a219aa473..9fc3f7f79 100644
--- lib/common_test/vsn.mk
+++ lib/common_test/vsn.mk
@@ -1 +1 @@
-COMMON_TEST_VSN = 1.15
+COMMON_TEST_VSN = 1.15.1
diff --git lib/kernel/test/gen_tcp_misc_SUITE.erl lib/kernel/test/gen_tcp_misc_SUITE.erl
index 929f66d40..331864b5d 100644
--- lib/kernel/test/gen_tcp_misc_SUITE.erl
+++ lib/kernel/test/gen_tcp_misc_SUITE.erl
@@ -50,9 +50,8 @@
 	 killing_acceptor/1,killing_multi_acceptors/1,killing_multi_acceptors2/1,
 	 several_accepts_in_one_go/1, accept_system_limit/1,
 	 active_once_closed/1, send_timeout/1, send_timeout_active/1,
-	 otp_7731/1, zombie_sockets/1, otp_7816/1, otp_8102/1,
-	 wrapping_oct/0, wrapping_oct/1,
-         otp_9389/1]).
+         otp_7731/1, zombie_sockets/1, otp_7816/1, otp_8102/1,
+         wrapping_oct/0, wrapping_oct/1, otp_9389/1, otp_13939/1]).
 
 %% Internal exports.
 -export([sender/3, not_owner/1, passive_sockets_server/2, priority_server/1, 
@@ -3014,3 +3013,42 @@ ok({ok,V}) -> V.
 get_hostname(Name) ->
     "@"++Host = lists:dropwhile(fun(C) -> C =/= $@ end, atom_to_list(Name)),
     Host.
+
+otp_13939(doc) ->
+    ["Check that writing to a remotely closed socket doesn't block forever "
+     "when exit_on_close is false."];
+otp_13939(suite) ->
+    [];
+otp_13939(Config) when is_list(Config) ->
+    {Pid, Ref} = spawn_opt(
+        fun() ->
+            {ok, Listener} = gen_tcp:listen(0, [{exit_on_close, false}]),
+            {ok, Port} = inet:port(Listener),
+
+            spawn_link(
+                fun() ->
+                    {ok, Client} = gen_tcp:connect("localhost", Port,
+                        [{active, false}]),
+                    ok = gen_tcp:close(Client)
+                end),
+
+            {ok, Accepted} = gen_tcp:accept(Listener),
+
+            ok = gen_tcp:send(Accepted, <<0:(10*1024*1024*8)>>),
+
+            %% The bug surfaces when there's a delay between the send
+            %% operations; inet:getstat is a red herring.
+            timer:sleep(100),
+
+            {error, Code} = gen_tcp:send(Accepted, <<0:(10*1024*1024*8)>>),
+            ct:pal("gen_tcp:send returned ~p~n", [Code])
+        end, [link, monitor]),
+
+    receive
+        {'DOWN', Ref, process, Pid, normal} ->
+            ok
+    after 1000 ->
+        demonitor(Ref, [flush]),
+        exit(Pid, normal),
+        ct:fail("Server process blocked on send.")
+    end.
diff --git lib/runtime_tools/doc/src/notes.xml lib/runtime_tools/doc/src/notes.xml
index 2bfc174ca..d50994306 100644
--- lib/runtime_tools/doc/src/notes.xml
+++ lib/runtime_tools/doc/src/notes.xml
@@ -32,6 +32,22 @@
   <p>This document describes the changes made to the Runtime_Tools
     application.</p>
 
+<section><title>Runtime_Tools 1.12.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    A faulty encoding comment was added when saving trace
+	    patterns to file. This is now corrected.</p>
+          <p>
+	    Own Id: OTP-14479</p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Runtime_Tools 1.12</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git lib/runtime_tools/src/dbg.erl lib/runtime_tools/src/dbg.erl
index e82f27896..92938ed5c 100644
--- lib/runtime_tools/src/dbg.erl
+++ lib/runtime_tools/src/dbg.erl
@@ -268,7 +268,7 @@ wtp(FileName) ->
 	{error, Reason} ->
 	    {error, Reason};
 	{ok, File} ->
-            io:put_chars(File, "%% coding: utf8\n"),
+            io:format(File, "%% ~s\n", [epp:encoding_to_string(utf8)]),
 	    pt_doforall(fun ({_, Val}, _) when is_list(Val) ->
 				io:format(File, "~tp.~n", [Val]);
 			    ({_, _}, _) ->
diff --git lib/runtime_tools/vsn.mk lib/runtime_tools/vsn.mk
index 5ee39a25f..729622103 100644
--- lib/runtime_tools/vsn.mk
+++ lib/runtime_tools/vsn.mk
@@ -1 +1 @@
-RUNTIME_TOOLS_VSN = 1.12
+RUNTIME_TOOLS_VSN = 1.12.1
diff --git lib/stdlib/doc/src/notes.xml lib/stdlib/doc/src/notes.xml
index 46454e9b8..bdd5b39cd 100644
--- lib/stdlib/doc/src/notes.xml
+++ lib/stdlib/doc/src/notes.xml
@@ -31,6 +31,38 @@
   </header>
   <p>This document describes the changes made to the STDLIB application.</p>
 
+<section><title>STDLIB 3.4.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+	    <p> A bug in <c>proc_lib:format()</c> introduced in
+	    Erlang/OTP 20.0 is corrected. </p>
+          <p>
+	    Own Id: OTP-14482 Aux Id: PR-1488 </p>
+        </item>
+        <item>
+          <p>
+	    Fix string:len/1 to be compatible with previous versions.</p>
+          <p>
+	    Own Id: OTP-14487 Aux Id: ERIERL-40 </p>
+        </item>
+        <item>
+          <p>
+	    In OTP-20.0, the behavior of c, make, and ct_make was
+	    changed so that in some cases the beam files by default
+	    would be written to the directory where the source files
+	    were found. This is now changed back to the old behavior
+	    so beam files are by default written to current
+	    directory.</p>
+          <p>
+	    Own Id: OTP-14489 Aux Id: ERL-438 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>STDLIB 3.4</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git lib/stdlib/src/c.erl lib/stdlib/src/c.erl
index 4ab9234b8..c04a201ce 100644
--- lib/stdlib/src/c.erl
+++ lib/stdlib/src/c.erl
@@ -255,7 +255,7 @@ safe_recompile(File, Options, BeamFile) ->
 compile_and_load(File, Opts0) when is_list(Opts0) ->
     Opts = [report_errors, report_warnings
             | ensure_from(filename:extension(File),
-                          ensure_outdir(filename:dirname(File), Opts0))],
+                          ensure_outdir(".", Opts0))],
     case compile:file(File, Opts) of
 	{ok,Mod} ->				%Listing file.
 	    purge_and_load(Mod, File, Opts);
diff --git lib/stdlib/src/proc_lib.erl lib/stdlib/src/proc_lib.erl
index 9ce8e7d60..d4d1bdcce 100644
--- lib/stdlib/src/proc_lib.erl
+++ lib/stdlib/src/proc_lib.erl
@@ -779,11 +779,13 @@ format_link_report([Link|Reps], Indent, Extra) ->
     LinkIndent = ["  ",Indent],
     [Indent,"neighbour:\n",format_report(Rep, LinkIndent, Extra)|
      format_link_report(Reps, Indent, Extra)];
-format_link_report([], _, _) ->
-    [].
+format_link_report(Rep, Indent, Extra) ->
+    format_report(Rep, Indent, Extra).
 
 format_report(Rep, Indent, Extra) when is_list(Rep) ->
     format_rep(Rep, Indent, Extra);
+format_report(Rep, Indent, {Enc,unlimited}) ->
+    io_lib:format("~s~"++modifier(Enc)++"p~n", [Indent, Rep]);
 format_report(Rep, Indent, {Enc,Depth}) ->
     io_lib:format("~s~"++modifier(Enc)++"P~n", [Indent, Rep, Depth]).
 
diff --git lib/stdlib/src/string.erl lib/stdlib/src/string.erl
index 6f7009b5d..4972da297 100644
--- lib/stdlib/src/string.erl
+++ lib/stdlib/src/string.erl
@@ -384,7 +384,7 @@ to_float(String) ->
     end.
 
 to_number(String, Number, Rest, List, _Tail) when is_binary(String) ->
-    BSz = length(List)-length(Rest),
+    BSz = erlang:length(List)-erlang:length(Rest),
     <<_:BSz/binary, Cont/binary>> = String,
     {Number, Cont};
 to_number(_, Number, Rest, _, Tail) ->
@@ -1344,7 +1344,7 @@ bin_search_str(Bin0, Start, Cont, [CP|_]=SearchCPs) ->
       String :: string(),
       Length :: non_neg_integer().
 
-len(S) -> length(S).
+len(S) -> erlang:length(S).
 
 %% equal(String1, String2)
 %%  Test if 2 strings are equal.
@@ -1689,7 +1689,7 @@ left(String, Len) when is_integer(Len) -> left(String, Len, $\s).
       Character :: char().
 
 left(String, Len, Char) when is_integer(Char) ->
-    Slen = length(String),
+    Slen = erlang:length(String),
     if
 	Slen > Len -> substr(String, 1, Len);
 	Slen < Len -> l_pad(String, Len-Slen, Char);
@@ -1714,7 +1714,7 @@ right(String, Len) when is_integer(Len) -> right(String, Len, $\s).
       Character :: char().
 
 right(String, Len, Char) when is_integer(Char) ->
-    Slen = length(String),
+    Slen = erlang:length(String),
     if
 	Slen > Len -> substr(String, Slen-Len+1);
 	Slen < Len -> r_pad(String, Len-Slen, Char);
@@ -1741,7 +1741,7 @@ centre(String, Len) when is_integer(Len) -> centre(String, Len, $\s).
 centre(String, 0, Char) when is_list(String), is_integer(Char) ->
     [];                       % Strange cases to centre string
 centre(String, Len, Char) when is_integer(Char) ->
-    Slen = length(String),
+    Slen = erlang:length(String),
     if
 	Slen > Len -> substr(String, (Slen-Len) div 2 + 1, Len);
 	Slen < Len ->
diff --git lib/stdlib/test/c_SUITE.erl lib/stdlib/test/c_SUITE.erl
index 4bd32a30f..f01988478 100644
--- lib/stdlib/test/c_SUITE.erl
+++ lib/stdlib/test/c_SUITE.erl
@@ -21,7 +21,9 @@
 -export([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1, 
 	 init_per_group/2,end_per_group/2]).
 -export([c_1/1, c_2/1, c_3/1, c_4/1, nc_1/1, nc_2/1, nc_3/1, nc_4/1,
-	 ls/1, memory/1]).
+	 c_default_outdir_1/1, c_default_outdir_2/1,
+         nc_default_outdir_1/1, nc_default_outdir_2/1,
+         ls/1, memory/1]).
 
 -include_lib("common_test/include/ct.hrl").
 
@@ -30,7 +32,10 @@
 suite() -> [{ct_hooks,[ts_install_cth]}].
 
 all() -> 
-    [c_1, c_2, c_3, c_4, nc_1, nc_2, nc_3, nc_4, ls, memory].
+    [c_1, c_2, c_3, c_4, nc_1, nc_2, nc_3, nc_4,
+     c_default_outdir_1, c_default_outdir_2,
+     nc_default_outdir_1, nc_default_outdir_2,
+     ls, memory].
 
 groups() -> 
     [].
@@ -124,6 +129,50 @@ nc_4(Config) when is_list(Config) ->
     Result = nc(R,[{outdir,W}]),
     {ok, m} = Result.
 
+c_default_outdir_1(Config) ->
+    R = filename:join(proplists:get_value(data_dir, Config), "m.erl"),
+    W = proplists:get_value(priv_dir, Config),
+    file:set_cwd(W),
+    Obj = "m" ++ code:objfile_extension(),
+    _ = file:delete(Obj),
+    false = filelib:is_file(Obj),
+    Result = c:c(R),
+    {ok, m} = Result,
+    true = filelib:is_file(Obj).
+
+c_default_outdir_2(Config) ->
+    R = filename:join(proplists:get_value(data_dir, Config), "m"),
+    W = proplists:get_value(priv_dir, Config),
+    file:set_cwd(W),
+    Obj = "m" ++ code:objfile_extension(),
+    _ = file:delete(Obj),
+    false = filelib:is_file(Obj),
+    Result = c:c(R),
+    {ok, m} = Result,
+    true = filelib:is_file(Obj).
+
+nc_default_outdir_1(Config) ->
+    R = filename:join(proplists:get_value(data_dir, Config), "m.erl"),
+    W = proplists:get_value(priv_dir, Config),
+    file:set_cwd(W),
+    Obj = "m" ++ code:objfile_extension(),
+    _ = file:delete(Obj),
+    false = filelib:is_file(Obj),
+    Result = c:nc(R),
+    {ok, m} = Result,
+    true = filelib:is_file(Obj).
+
+nc_default_outdir_2(Config) ->
+    R = filename:join(proplists:get_value(data_dir, Config), "m"),
+    W = proplists:get_value(priv_dir, Config),
+    file:set_cwd(W),
+    Obj = "m" ++ code:objfile_extension(),
+    _ = file:delete(Obj),
+    false = filelib:is_file(Obj),
+    Result = c:nc(R),
+    {ok, m} = Result,
+    true = filelib:is_file(Obj).
+
 ls(Config) when is_list(Config) ->
     Directory = proplists:get_value(data_dir, Config),
     ok = c:ls(Directory),
diff --git lib/stdlib/test/proc_lib_SUITE.erl lib/stdlib/test/proc_lib_SUITE.erl
index 029e6286e..c4fafe82a 100644
--- lib/stdlib/test/proc_lib_SUITE.erl
+++ lib/stdlib/test/proc_lib_SUITE.erl
@@ -28,7 +28,7 @@
 	 init_per_group/2,end_per_group/2, 
 	 crash/1, stacktrace/1, sync_start_nolink/1, sync_start_link/1,
          spawn_opt/1, sp1/0, sp2/0, sp3/1, sp4/2, sp5/1, '\x{447}'/0,
-	 hibernate/1, stop/1, t_format/1]).
+	 hibernate/1, stop/1, t_format/1, t_format_arbitrary/1]).
 -export([ otp_6345/1, init_dont_hang/1]).
 
 -export([hib_loop/1, awaken/1]).
@@ -51,7 +51,7 @@ suite() -> [{ct_hooks,[ts_install_cth]}].
 
 all() -> 
     [crash, stacktrace, {group, sync_start}, spawn_opt, hibernate,
-     {group, tickets}, stop, t_format].
+     {group, tickets}, stop, t_format, t_format_arbitrary].
 
 groups() -> 
     [{tickets, [], [otp_6345, init_dont_hang]},
@@ -78,6 +78,14 @@ end_per_group(_GroupName, Config) ->
 %% synchronous, and we want to test that the crash report is ok.
 %%-----------------------------------------------------------------
 crash(Config) when is_list(Config) ->
+    ok = application:unset_env(kernel, error_logger_format_depth),
+    crash_1(Config),
+    ok = application:set_env(kernel, error_logger_format_depth, 30),
+    crash_1(Config),
+    ok = application:unset_env(kernel, error_logger_format_depth),
+    ok.
+
+crash_1(_Config) ->
     error_logger:add_report_handler(?MODULE, self()),
 
     %% Make sure that we don't get a crash report if a process
@@ -562,9 +570,32 @@ t_format() ->
 
     ok.
 
+t_format_arbitrary(_Config) ->
+    error_logger:tty(false),
+    try
+        t_format_arbitrary()
+    after
+        error_logger:tty(true)
+    end,
+    ok.
+
+t_format_arbitrary() ->
+    A = list_to_atom([1024]),
+    do_test_format([fake_report, A], unlimited),
+    do_test_format([fake_report, A], 20),
+
+    do_test_format([fake_report, foo], unlimited),
+    do_test_format([fake_report, foo], 20),
+    do_test_format([fake_report, []], unlimited),
+    do_test_format([fake_report, []], 20).
+
 do_test_format(Report, Depth) ->
-    io:format("*** Depth = ~p", [Depth]),
-    S0 = proc_lib:format(Report, latin1, Depth),
+    do_test_format(Report, latin1, Depth),
+    do_test_format(Report, unicode, Depth).
+
+do_test_format(Report, Encoding, Depth) ->
+    io:format("*** Depth = ~p, Encoding = ~p", [Depth, Encoding]),
+    S0 = proc_lib:format(Report, Encoding, Depth),
     S = lists:flatten(S0),
     io:put_chars(S),
     length(S).
@@ -584,7 +615,7 @@ init(Tester) ->
     {ok, Tester}.
 
 handle_event({error_report, _GL, {Pid, crash_report, Report}}, Tester) ->
-    io:format("~s\n", [proc_lib:format(Report)]),
+    io:format("~ts\n", [proc_lib:format(Report)]),
     Tester ! {crash_report, Pid, Report},
     {ok, Tester};
 handle_event(_Event, State) ->
diff --git lib/stdlib/vsn.mk lib/stdlib/vsn.mk
index f062c7fe6..8a83cdec1 100644
--- lib/stdlib/vsn.mk
+++ lib/stdlib/vsn.mk
@@ -1 +1 @@
-STDLIB_VSN = 3.4
+STDLIB_VSN = 3.4.1
diff --git lib/tools/doc/src/notes.xml lib/tools/doc/src/notes.xml
index bdd545535..f0df43bf2 100644
--- lib/tools/doc/src/notes.xml
+++ lib/tools/doc/src/notes.xml
@@ -31,6 +31,26 @@
   </header>
   <p>This document describes the changes made to the Tools application.</p>
 
+<section><title>Tools 2.10.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    In OTP-20.0, the behavior of c, make, and ct_make was
+	    changed so that in some cases the beam files by default
+	    would be written to the directory where the source files
+	    were found. This is now changed back to the old behavior
+	    so beam files are by default written to current
+	    directory.</p>
+          <p>
+	    Own Id: OTP-14489 Aux Id: ERL-438 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Tools 2.10</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git lib/tools/src/make.erl lib/tools/src/make.erl
index ce30156db..6554d338a 100644
--- lib/tools/src/make.erl
+++ lib/tools/src/make.erl
@@ -267,15 +267,47 @@ include_opt([]) ->
 
 recompile(File, true, _Load, _Opts) ->
     io:format("Out of date: ~ts\n",[File]);
-recompile(File, false, noload, Opts) ->
+recompile(File, false, Load, Opts) ->
     io:format("Recompile: ~ts\n",[File]),
-    compile:file(File, [report_errors, report_warnings, error_summary |Opts]);
-recompile(File, false, load, Opts) ->
-    io:format("Recompile: ~ts\n",[File]),
-    c:c(File, Opts);
-recompile(File, false, netload, Opts) ->
-    io:format("Recompile: ~ts\n",[File]),
-    c:nc(File, Opts).
+    case compile:file(File, [report_errors, report_warnings |Opts]) of
+        Ok when is_tuple(Ok), element(1,Ok)==ok ->
+            maybe_load(element(2,Ok), Load, Opts);
+        _Error ->
+            error
+    end.
+
+maybe_load(_Mod, noload, _Opts) ->
+    ok;
+maybe_load(Mod, Load, Opts) ->
+    %% We have compiled File with options Opts. Find out where the
+    %% output file went to, and load it.
+    case compile:output_generated(Opts) of
+	true ->
+            Dir = proplists:get_value(outdir,Opts,"."),
+            do_load(Dir, Mod, Load);
+	false ->
+	    io:format("** Warning: No object file created - nothing loaded **~n"),
+	    ok
+    end.
+
+do_load(Dir, Mod, load) ->
+    code:purge(Mod),
+    case code:load_abs(filename:join(Dir, Mod),Mod) of
+        {module,Mod} ->
+            {ok,Mod};
+        Other ->
+            Other
+    end;
+do_load(Dir, Mod, netload) ->
+    Obj = atom_to_list(Mod) ++ code:objfile_extension(),
+    Fname = filename:join(Dir, Obj),
+    case file:read_file(Fname) of
+        {ok,Bin} ->
+            rpc:eval_everywhere(code,load_binary,[Mod,Fname,Bin]),
+            {ok,Mod};
+        Other ->
+            Other
+    end.
 
 exists(File) ->
     case file:read_file_info(File) of
diff --git lib/tools/test/make_SUITE.erl lib/tools/test/make_SUITE.erl
index 2f6fe1c73..02da4f4ac 100644
--- lib/tools/test/make_SUITE.erl
+++ lib/tools/test/make_SUITE.erl
@@ -36,7 +36,7 @@
 suite() -> [{ct_hooks,[ts_install_cth]}].
 
 all() -> 
-    [make_all, make_files, recompile_on_changed_include,
+    [make_all, make_files, load, netload, recompile_on_changed_include,
      emake_opts, {group, otp_6057}].
 
 groups() -> 
@@ -55,6 +55,21 @@ init_per_group(_GroupName, Config) ->
 end_per_group(_GroupName, Config) ->
     otp_6057_end(Config).
 
+init_per_testcase(_,Config) ->
+    Config.
+
+end_per_testcase(netload,_Config) ->
+    %% Stop slave - in case of failure
+    Nodes = nodes(),
+    case [N || N <- Nodes,
+               "make_SUITE_netload" == hd(string:lexemes(atom_to_list(N),"@"))] of
+        [Node] ->
+            ct_slave:stop(Node);
+        _ ->
+            ok
+    end;
+end_per_testcase(_,_Config) ->
+    ok.
 
 test_files() -> ["test1", "test2", "test3", "test4"].
 
@@ -83,6 +98,32 @@ make_files(Config) when is_list(Config) ->
     ensure_no_messages(),
     ok.
 
+load(Config) ->
+    Current = prepare_data_dir(Config),
+    code:purge(test1),
+    code:delete(test1),
+    false = code:is_loaded(test1),
+    up_to_date = make:files([test1], [load]),
+    {file,_} = code:is_loaded(test1),
+    file:set_cwd(Current),
+    ensure_no_messages(),
+    ok.
+
+netload(Config) ->
+    Current = prepare_data_dir(Config),
+    code:purge(test1),
+    code:delete(test1),
+    false = code:is_loaded(test1),
+    {ok,Node} = ct_slave:start(make_SUITE_netload),
+    up_to_date = make:files([test1], [netload]),
+    timer:sleep(1000), % async, so give some time
+    {file,F} = code:is_loaded(test1),
+    {file,F} = rpc:call(Node,code,is_loaded,[test1]),
+    ct_slave:stop(Node),
+    file:set_cwd(Current),
+    ensure_no_messages(),
+    ok.
+
 recompile_on_changed_include(Config) ->
     Current = prepare_data_dir(Config),
 
diff --git lib/tools/vsn.mk lib/tools/vsn.mk
index 8aa7814e1..831d85021 100644
--- lib/tools/vsn.mk
+++ lib/tools/vsn.mk
@@ -1 +1 @@
-TOOLS_VSN = 2.10
+TOOLS_VSN = 2.10.1
diff --git otp_versions.table otp_versions.table
index 65b5cfee5..64baa3fa9 100644
--- otp_versions.table
+++ otp_versions.table
@@ -1,3 +1,4 @@
+OTP-20.0.1 : common_test-1.15.1 erts-9.0.1 runtime_tools-1.12.1 stdlib-3.4.1 tools-2.10.1 # asn1-5.0 compiler-7.1 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.2 cosTime-1.2.2 cosTransactions-1.3.2 crypto-4.0 debugger-4.2.2 dialyzer-3.2 diameter-2.0 edoc-0.9 eldap-1.2.2 erl_docgen-0.7 erl_interface-3.10 et-1.6 eunit-2.3.3 hipe-3.16 ic-4.4.2 inets-6.4 jinterface-1.8 kernel-5.3 megaco-3.18.2 mnesia-4.15 observer-2.4 odbc-2.12 orber-3.8.3 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.5 public_key-1.4.1 reltool-0.7.4 sasl-3.0.4 snmp-5.2.6 ssh-4.5 ssl-8.2 syntax_tools-2.1.2 wx-1.8.1 xmerl-1.3.15 :
 OTP-20.0 : asn1-5.0 common_test-1.15 compiler-7.1 cosProperty-1.2.2 crypto-4.0 debugger-4.2.2 dialyzer-3.2 diameter-2.0 edoc-0.9 erl_docgen-0.7 erl_interface-3.10 erts-9.0 eunit-2.3.3 hipe-3.16 inets-6.4 jinterface-1.8 kernel-5.3 megaco-3.18.2 mnesia-4.15 observer-2.4 orber-3.8.3 parsetools-2.1.5 public_key-1.4.1 reltool-0.7.4 runtime_tools-1.12 sasl-3.0.4 snmp-5.2.6 ssh-4.5 ssl-8.2 stdlib-3.4 syntax_tools-2.1.2 tools-2.10 wx-1.8.1 xmerl-1.3.15 # cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosTime-1.2.2 cosTransactions-1.3.2 eldap-1.2.2 et-1.6 ic-4.4.2 odbc-2.12 os_mon-2.4.2 otp_mibs-1.1.1 :
 OTP-19.3.6 : erts-8.3.5 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 inets-6.3.9 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 ssl-8.1.3 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 xmerl-1.3.14 :
 OTP-19.3.5 : erts-8.3.4 xmerl-1.3.14 # asn1-4.0.4 common_test-1.14 compiler-7.0.4 cosEvent-2.2.1 cosEventDomain-1.2.1 cosFileTransfer-1.2.1 cosNotification-1.2.2 cosProperty-1.2.1 cosTime-1.2.2 cosTransactions-1.3.2 crypto-3.7.4 debugger-4.2.1 dialyzer-3.1.1 diameter-1.12.2 edoc-0.8.1 eldap-1.2.2 erl_docgen-0.6.1 erl_interface-3.9.3 et-1.6 eunit-2.3.2 gs-1.6.2 hipe-3.15.4 ic-4.4.2 inets-6.3.9 jinterface-1.7.1 kernel-5.2 megaco-3.18.1 mnesia-4.14.3 observer-2.3.1 odbc-2.12 orber-3.8.2 os_mon-2.4.2 otp_mibs-1.1.1 parsetools-2.1.4 percept-0.9 public_key-1.4 reltool-0.7.3 runtime_tools-1.11.1 sasl-3.0.3 snmp-5.2.5 ssh-4.4.2 ssl-8.1.3 stdlib-3.3 syntax_tools-2.1.1 tools-2.9.1 typer-0.9.12 wx-1.8 :
